q 

Contents

 

 

 

 

 

CHAPTER 1 WHY CMAKE? 1
1.1 The History of CMake 3

1.2 Why Not Use Autoconf? 3

1.3 Why Not Use JAM, qmake, SCons, or ANT? 4

1.4 Why Not Script It, Yourself? 4

1.5 On What Platforms Does CMake Run? 5
CHAPTER 2 GETTING STARTED 7
2.1 Getting and Installing CMake on Your Computer 7
UNIX and Mac Binary Installations 7

Windows Binary Installation 7

2.2 Building CMake Yourself 8
2.3 Basic CMake Usage and Syntax 8
2.4 Hello World for CMake 9
2.5 How to Run CMake? 10
Running CMake ’s Qt Interface 11

Running the ccmake Curses Interface I3

Running CMake from the Command Line I5

Specijying the Compiler to CMake 15

Dependency Analysis I 6

2.6 Editing CMakeLists Files 17
2.7 Setting Initial Values for CMake 17
2.8 Building Your Project 19
CHAPTER 3 KEY CONCEPTS 21
3.1 Main Structures 21
3.2 Targets 24
3.3 Source Files 25
3.4 Directories, Generators, Tests, and Properties 26
3.5 Variables and Cache Entries 27
3.6 Build Conﬁgurations 32
CHAPTER 4 WRITING CMAKELISTS FILES 33
4.1 CMake Syntax 33
4.2 Basic Commands 34
4.3 Flow Control 35
4.4 Regular Expressions 42

 

 

 

4.5 Checking Versions of CMake 44
4.6 Using Modules 45
Using CMake with SWIG 48

Using CMake with Qt 49

Using CMake with FLT K 50

4.7 Policies 50
Updating a Project For a New Version of CMake 53

4.8 . Linking Libraries 57
Speciﬁzing Optimized or Debug Libraries with a Target 59

4.9 Shared Libraries and Loadable Modules 59
4.10 Shared Library Versioning 64
4.11 Installing Files 66
Installing Prerequisite Shared Libraries 76

4.12 Advanced Commands 82
CHAPTER 5 SYSTEM INSPECTION 85
5.1 Using Header Files and Libraries 85
5.2 System Properties 87
5.3 Finding Packages 92
5.4 Built—in Find Modules 93
5.5 How to Pass Parameters to a Compilation? 95
5.6 How to Conﬁgure a Header File 97
5.7 Creating CMake Package Conﬁguration Files 99
CHAPTER 6 CUSTOM COMMANDS AND TARGETS 103
6.1 Portable Custom Commands 103
6.2 Using add_customicommand on a Target 105
How to Copy an Executable Once it is Built? 106

6.3 Using add_customicommand to Generate a File 107
Using an Executable to Build a Source File I 07

6.4 Adding a Custom Target 108
6.5 Specifying Dependencies and Outputs 111
6.6 When There Isn’t One Rule For One Output 112
A Single Command Producing Multiple Outputs I 12

Having One Output That Can Be Generated By Diﬂerent Commands I I 2
CHAPTER 7 CONVERTING EXISTING SYSTEMS TO CMAKE 115
7.1 Source Code Directory Structures 115
7.2 Build Directories 1 17
7.3 Useful CMake Commands When Converting Projects 119
7.4 Converting UNIX Makeﬁles 120

 

 

 

 

7.5 Converting Autoconf Based Projects 121
7.6 Converting Windows Based Workspaces 123
CHAPTER 8 CROSS COMPILING WITH CMAKE 125
8.1 Toolchain Files 126
Finding External Libraries, Programs and Other Files 128

8.2 System Inspection 130
Using Compile Checks I 31

8.3 Running Executables Built in the Project 133
8.4 Cross Compiling Hello World 136
8.5 Cross Compiling for a Microcontroller 140
8.6 Cross Compiling an Existing Project 143
8.7 Cross Compiling a Complex Project - VTK 145
8.8 Some Tips and Tricks 147
CHAPTER 9 PACKAGING WITH CPACK 149
9.1 CPack Basics 149
Simple Example 150

What Happens When CPack.emake Is Included? I 5 I

Adding Custom CPack Options I 52

Options Added by CPack I 53

9.2 CPack Source Packages 154
9.3 CPack Installer Commands 154
9.4 CPack for Windows Installer NSIS 156
CPack Variables Used by CMake for NSIS 156

Creating Windows Short Cuts in the Start Menu [61
Advanced NSIS CPack Options I 61

Setting File Extension Associations With NSIS I 62

Installing Il/[icrosoft Run Time Libraries 1 63

CPack Component Install Support I 63

9.5 CPack for Cygwin Setup 173
9.6 CPack for Mac OS X PackageMaker 176
9.7 CPack for Mac OS X Drag and Drop 178
9.8 CPack for Mac OS X X11 Applications 180
9.9 CPack for Debian Packages 182
9.10 CPack for RPM 183
9.11 CPack Files 183
CHAPTER 10 AUTOMATION & TESTING WITH CMAKE 185
10.1 Testing with CMake, CTest, and CDash 185
10.2 How Does CMake Facilitate Testing? 186

vi

10.3 Additional Test Properties 187
10.4 Testing Using CTest 189
10.5 Using CTest to Drive Complex Tests 191
10.6 Handling a Large Number of Tests 192
10.7 Producing Test Dashboards 194
Adding CDash Dashboard Support to a Project 196

~ Client Setup 199
10.8 Customizing Dashboards for a Project 202
Dashboard Submissions Settings 202

Filtering Errors and Warnings 203

Adding Notes to a Dashboard 205

10.9 Setting up Automated Dashboard Clients 206
Settings for Continuous Dashboards 210

Variables Available in CT est Scripts 212

10.10 Advanced CTest Scripting 212
Limitations of Traditional C T est Scripting 213
Extended C Test Scripting 213

10.1 1 Setting up a Dashboard Server 218
CDash Server 218
Advanced Server Management 220

Build Groups 223

Email 225

Sites 226

Graphs 22 7

Adding Notes to a Build 228

Logging 229

Test Timing 229

Mobile Support 230

Backing up CDash 230
Upgrading CDash 23 l

CDash Maintenance 232

10.12 Subprojects 233
Using ctest_submit with PARTS and FILES 236

Splitting Your Project into Multiple Subprojects 23 7

CHAPTER 11 PORTING CMAKE TO NEW PLATFORMS AND LANGUAGESZ41

l 1.1 The Determine System Process 241
11.2 The Enable Language Process 242
11.3 Porting to a New Platform 244
11.4 Adding a New Language 246
l 1.5 Rule Variable Listing 247

General Tag Variables 24 7

Language Speciﬁc Information 248

 

 

 

 

11.6 Compiler and Platform Examples 248
Como Compiler 248

Borland Compiler 249

11.7 Extending CMake 250
Creating a Loaded Command 250

Using a Loaded Command 25]

CHAPTER 12 TUTORIALS 255
12.1 A Basic Starting Point (Step 1) 255
Adding a Version Number and Conﬁgured Header File 256

12.2 Adding a Library (Step 2) 258
12.3 Installing and Testing (Step 3) 260
12.4 Adding System Introspection (Step 4) 262
12.5 Adding a Generated File and Generator (Step 5) 263
12.6 Building an Installer (Step 6) 267
12.7 Adding Support for a Dashboard (Step 7) 268
APPENDIX A - VARIABLES 269
Variables That Change Behavior 269
Variables That Describe the System 272
Variables for Languages 274
Variables That Control the Build 278
Variables That Provide Information 280
APPENDIX B — COMMAND LINE REFERENCE 287
CMake Command Line Options 287
CMake Generators 292
CTest Command Line Options 294
CPack Command Line Options 298
CPack Generators 299
APPENDIX C — LISTFILE COMMANDS 301
Current Commands 301
Compatibility Commands 366
APPENDIX D — SELECTED MODULES 373

 

CMake Modules

373

vii

viii

 

APPENDIX E - PROPERTIES 411
Properties of Global Scope 411
Properties on Directories 414
Properties on Targets 417
Properties on Tests 431
Properties on Source Files 431
Properties on Cache Entries 434

APPENDIX F — CMAKE POLICIES 437

 

INDEX

447

 

Chapter 1

 

Why CMake?

If you have ever maintained the build and installation process for a software package, you will be interested in CMake. CMake is an open source build manager for software projects that allows developers to specify build parameters in a simple portable text ﬁle format. This ﬁle is then used by CMake to generate project ﬁles for native build tools including Integrated Development Environments such as Microsoft Visual Studio or Apple’s Xcode, as well as UNIX, Linux, NMake, and Borland style Makeﬁles. CMake handles the difﬁcult aspects of building software such as cross platform builds, system introspection, and user customized builds, in a simple manner that allows users to easily tailor builds for complex hardware and software systems.

For any project, and especially cross platform projects, there is a need for a uniﬁed buildsystem. Many projects today ship with both a UNIX Makeﬁle (or Makeﬁle.in) and aMicrosoﬁ Visual Studio workspace. This requires that developers constantly try to keep bothbuild systems up to date and consistent with each other. To target additional build systemssuch as Borland or Xcode requires even more custom copies of these ﬁles, creating an evenbigger problem. This problem is compounded if you try to support optional components, suchas including JPEG support if libjpeg is available on the system. CMake solves this byconsolidating these different operations into one simple easy to understand ﬁle format.

If you have multiple developers working on a project, or multiple target platforms, then the
software will have to be built on more than one computer. Given the wide range of installed
software and custom options that are involved with setting up a modern computer, the chances
are that two computers running the same OS will be slightly different. CMake provides many
beneﬁts for single platform multi—machine development environments including:

2 WhLCMake?

 

o The ability to automatically search for programs, libraries, and header files that may be
required by the software being built. This includes the ability to consider environment
variables and Window’s registry settings when searching.

o The ability to build in a directory tree outside of the source tree, This is a useful feature
found on many UNIX platforms; CMake provides this feature on Windows as well. This
allows a developer to remove an entire build directory without fear of removing source
ﬁles.

0 The ability to create complex custom commands for automatically generated ﬁles such
as Qt's moc (qt.nokia.com), The Insight Toolkit’s CABLE wrappers
(publickitware.com/Cable/HTML/Index.html) and SWIG (www.swig.org) wrapper
generators. These commands are used to generate new source ﬁles during the build
process that are in turn compiled into the software.

0 The ability to select optional components at conﬁguration time. For example, several of
VTK’s libraries are optional, and CMake provides an easy way for users to select which
libraries are built.

0 The ability to automatically generate workspaces and projects from a simple text ﬁle.
This can be very handy for systems that have many programs or test cases, each of
which requires a separate project ﬁle, typically a tedious manual process to create using
an IDE.

0 The ability to easily switch between static and shared builds. CMake knows how to
create shared libraries and modules on all platforms supported. Complicated platform-
speciﬁc linker ﬂags are handled, and advanced features like built in run time search
paths for shared libraries are supported on many UNIX systems.

0 Automatic generation of ﬁle dependencies and support for parallel builds on most
platforms.

When developing cross platform software, CMake provides a number of additional features:

0 The ability to test for machine byte order and other hardware speciﬁc characteristics.

0 A single set of build conﬁguration ﬁles that work on all platforms. This avoids the
problem of developers having to maintain the same information in several different
formats inside a project.

0 Support for building shared libraries on all platforms that support it.

o The ability to conﬁgure ﬁles with system dependent information such as the location of
data ﬁles and other information. CMake can create header ﬁles that contain information
such as paths to data ﬁles and other information in the form of #deﬁne macros. System
speciﬁc ﬂags can also be placed in conﬁgured header ﬁles. This has advantages over
command line 7D options to the compiler because it allows other build systems to use
the CMake built library without having to specify the exact same command line options
used during the build.

The History of CMake 3

1.1 The History of CMake

CMake development began in 1999 as part of the Insight Toolkit (ITK, www.itk.org) funded
by the US National Library of Medicine. ITK is a large software project that works on many
platforms and can interact with many other software packages. To support this, a powerful,
yet easy to use, build tool was required. Having worked with build systems for large projects
in the past, the developers designed CMake to address these needs. Since then CMake has
continuously grown in popularity, with many projects and developers adopting it for its ease
of use and ﬂexibility. Since 1999 CMake has been under active development and has matured
to the point where it is a proven solution for a wide range of build issues. The most telling
example of this is the successful adoption of CMake as the build system of the K Desktop
Environment (KDE), arguably the largest open source software project in existence.

One of the recent additions to CMake is the inclusion of software testing support in the form
of CTest. Part of the process of testing software involves building the software, possibly
installing it, and determining what parts of the software are appropriate for the current system.
This makes CTest a logical extension of CMake as it already has most of this information. In
a similar vein, a new CMake feature is CPack, which is designed to support cross platform
distribution of software. It provides a cross platform approach to creating native installations
for your software, making use of existing popular packages such as NSIS, RPM, Cygwin, and
PackageMaker.

Other recent additions to CMake include support for Apple’s Xcode IDE and support for
Microsoft’s Visual Studio 10. With CMake, once you write your input ﬁles you get support
for new compilers and build systems for free because the support for them is built into new
releases of CMake, not tied to your software distribution. Another recent addition to CMake is
support for cross compiling to other operating systems or embedded devices. Many
commands in CMake now properly handle the differences between the host system and the
target platform when cross compiling.

1.2 Why Not Use Autoconf?

Before developing CMake its authors had experience with the existing set of available tools.
Autoconf combined with automake provides some of the same functionality as CMake, but to
use these tools on a Windows platform requires the installation of many additional tools not
found natively on a Windows box. In addition to requiring a host of tools, autoconf can be
difﬁcult to use or extend and impossible for some tasks that are easy in CMake. Even if you
do get autoconf and its required environment running on your system, it generates Makeﬁles
that will force users to the command line. CMake on the other hand provides a choice,
allowing developers to generate project ﬁles that can be used directly from the IDE to which
Windows and Xcode developers are accustomed.

4 Why CMake?

While autoconf supports user speciﬁed options, it does not support dependent options where one option depends on some other property or selection. For example, in CMake you could have a user option to enable multithreading be dependent on ﬁrst determining if the user’s system has multithreading support. CMake provides an interactive user interface, making it easy for the user to see what options are available and how to set them.

For UNIX users, CMake also provides automated dependency generation that is not done directly by autoconf. CMake’s simple input format is also easier to read and maintain than a combination of Makeﬁle.in and conﬁgurein ﬁles. The ability of CMake to remember and chain library dependency information has no equivalent in autoconf/automake.

1.3 Why Not Use JAM, qmake, SCons, or ANT?

Other tools such as ANT, qmake, SCons, and JAM have taken different approaches to solving these problems and they have helped us to shape CMake. Of the four, qmake, is the most similar to CMake although it lacks much of the system interrogation that CMake provides. Qmake‘s input format more is closely related to a traditional Makeﬁle. ANT, JAM and SCons are also cross-platform although they do not support generating native project ﬁles. They do
break away from the traditional Makeﬁle oriented input with ANT using XML, JAM using its own language, and SCons using Python. A number of these tools run the compiler directly, as opposed to letting the system’s build process perform that task. Many of these tools require other tools such as Python or Java to be installed before they will work.

1.4 Why Not Script It Yourself?

Some projects use existing scripting languages such as Perl or Python to conﬁgure build processes. Although similar functionality can be achieved with systems like this, over-use of tools can make the build process more of an Easter egg hunt than a simple—to-use build system. When building your software package users are forced to ﬁnd and install version 4.3.2 of this, and 3.2.4 of that, before they can even start the build process. To avoid that
problem, it was decided that CMake would require no more tools than the software it was being used to build would require. At a minimum using CMake requires a C compiler, that compiler's native build tools, and a CMake executable. CMake was written in C++, requires only a C++ compiler to build and precompiled binaries are available for most systems. Scripting it yourself also typically means you will not be generating native Xcode or Visual Studio workspaces, making Mac and Windows builds limited.

On What Platforms Does CMake Run? 5

1.5 On What Platforms Does CMake Run?

CMake runs on a wide variety of platforms including Microsoft Windows, Apple Mac OS X, and most UNIX or UNIX-like platforms. At the time of the writing of this book CMake was tested nightly on the following platforms: Windows 98/2000/XP/Vista/7, AIX, HPUX, IRIX, Linux, Mac OS X, Solaris, OSF, QNX, CYGWIN, MinGW, and FreeBSD. You can check www.cmake.org for a current list of tested platforms.

Likewise, CMake supports most common compilers. It supports the GNU compiler on all CMake supported platforms. Other tested compilers include Visual Studio 6 through 10, Intel C, SGI CC, Mips Pro, Borland, Sun CC and HP aCC. CMake should work for most UNIX-style compilers out of the box. If the compiler takes arguments in a strange way, then see the section Porting CMake to New Platform on page 241 for information on how to customize CMake for a new compiler.

 

Chapter 2

 

Getting Started

2.1 Getting and Installing CMake on Your Computer

Before using CMake you will need to install or build the CMake binaries on your system. On many systems you may ﬁnd that CMake is already installed, or is available for install with the standard package manager tool for the system. Cygwin, Debian, FreeBSD, Mac OS X Fink, and many others all have CMake distributions. If your system does not have a CMake package, you can ﬁnd CMake precompiled for most common architectures at
www.cmake.org. If you do not ﬁnd binaries for your system precompiled, then you can build CMake from source. To build CMake you will need a modern C++ compiler.

UNIX and Mac Binary Installations

If your system provides CMake as one of its standard packages, follow your system’s package installation instructions. If your system does not have CMake, or has an out of date version of CMake, you can download precompiled binaries from www.cmake.org. The binaries from www.cmake.org come in the form of a compressed tar ﬁle. The tar ﬁle contains a README ﬁle and an enclosed tar ﬁle. The README ﬁle contains a manifest of the ﬁles contained in the enclosed tar ﬁle, and some instructions. To install, simply extract the enclosed tar ﬁle into a destination directory (typically /usr/local). However, it can be any directory, and does not require root privileges for installation.

Windows Binary Installation

For Windows CMake has a NullSoﬁ install ﬁle available for download from www.cmake.org. To install this ﬁle, simply run the executable on the windows machine on which you want to install CMake. You will be able to run CMake from the Start Menu after it is installed.

8 Gettinq Started

 

2.2 Building CMake Yourself

If binaries are not available for your system, or if binaries are not available for the version of CMake you wish to use, you can build CMake from the source code. You can obtain the CMake source code by following the instructions at www.cmake.org. Once you have the source code it can be built in two different ways. If you have a version of CMake on your system you can use it to build other versions of CMake. Generally the current development version of CMake can always be built from the previous release of CMake. This is how new versions of CMake are built on most Windows systems.

The second way to build CMake is by running its bootstrap build script. To do this you change directory into your CMake source directory and type

./bootstrap
make
make install

The make install step is optional since CMake can run directly from the build directory if desired. On UNIX, if you are not using the GNU C++ compiler, you need to tell the bootstrap script which compiler you want to use. This is done by setting the environment variable CXX before running bootstrap. If you need to use any special ﬂags with your compiler, set the CXXFLAGS environment variable. For example, on the SGI with the 7.3X compiler, you would build CMake like this:

Cd CMake

(setenv CXX CC; setenv CXXFLAGS "—LANsttd"; ./bootstrap)
make

make install

2.3 Basic CMake Usage and Syntax

Using CMake is simple. The build process is controlled by creating one or more CMakeLists ﬁles (actually CMakeLists.txt but this guide will leave off the extension in most cases) in each of the directories that make up a project. The CMakeLists ﬁles should contain the project description in CMake's simple language. The language is expressed as a series of commands. Each command is evaluated in the order that it appears in the CMakeLists ﬁle. The commands have the form command (args...)

Hello World for CMake 9

 

where command is the name of the command, and args is a white—space separated list of arguments. (Arguments with embedded white-space should be double quoted.) CMake is case insensitive to command names as of version 2.2. So where you see command you could use COMMAND or Command instead. Older versions of CMake only accepted uppercase commands.

CMake supports simple variables that can be either strings or lists of strings. Variables are referenced using a ${VAR} syntax. Multiple arguments can be grouped together into a list using the set command. All other commands expand the lists as if they had been passed into the command with white-space separation. For example, set (Foo a b c) will result in setting the variable Foo to a b c, and if Foo is passed into another command command ($ {Foo} ) it would be equivalent to command (a b c) . Ifyou want to pass a list of arguments to a command as if it were a single argument simply double quote it. For example command ( "$ {Foo} ") would be invoked passing only one argument equivalent to command(
"a b c" ).

System environment variables and Windows registry values can be accessed directly in CMake. To access system environment variables the syntax $ENV{VAR} is used. CMake can also reference registry entries in many commands using a syntax of the form [HKEYiCURRENTiUSER\\Software\\pathl\\path2;key], where the paths are built from the registry tree and key.

2.4 Hello World for CMake

For starters let us consider the simplest possible CMakeLists ﬁle. To compile an executable from one source ﬁle the CMakeLists ﬁle would contain two lines:

project (Hello)
addﬂexecutable (Hello Hello.c)

To build the Hello executable you follow the process described in Running CMake (See section 2.5) to generate the Makeﬁles or Microsoft project ﬁles. The project command indicates what the name of the resulting workspace should be and the addiexecutable command adds executable an target to the build process. That’s all there is to it for this simple example. If your project requires a few ﬁles it is also quite easy, just modify the addﬁexecutable line as shown below.

addiexecutable (Hello Hello.c File2.c File3.c File4.c)

addiexecutable is just one of many commands available in CMake. Consider the more
complicated example below.

10 Getting Started

cmake_minimumwrequired (2.6)
project (HELLO)

set (HELLO_SRCS Hello.c File2.c File3.c)

if (WIN32)

set<HELLOiSRCS ${HELLOiSRCS} WinSupport.c)
else ()

set(HELLOiSRCS ${HELLO#SRCS} UniXSupport.c)
endif 0

addmexecutable (Hello ${HELLOiSRCS})

# look for the Tel library
find_library (TCLiLIBRARY
NAMES tel tc184 tcl83 tcl82 tcl8O
PATHS /usr/lib /usr/local/lib
>

if (TCL#LIBRARY)
target linkulibrary (Hello ${TCL>LIBRARY})
endif 0

In this example the set command is used to group together source ﬁles into a list. The if command is used to add either WinSupport.c or UnixSupport.c to this list based on whether or not CMake is running on Windows. Finally, the add_executable command is used to build the executable with the ﬁles listed in the variable HELLO_SRCS. The findlibrary command looks for the Tel library under a few different names and in a few different paths. An if command checks if the TCL_LIBRARY was found and if so adds it to the link line for the Hello executable target. Note the use of the # character to denote a comment line. All characters from the # to the end of the line are considered to be part of the comment.

2.5 How to Run CMake?

Once CMake has been installed on your system, using it to build a project is easy. There are two main directories CMake uses when building a project: the source directory and the binary directory. The source directory is where the source code for your project is located. This is also where the CMakeLists ﬁles will be found. The binary directory is where you want CMake to put the resulting object ﬁles, libraries, and executables. Typically CMake will not write any ﬁles to the source directory, only the binary directory. If you want to you can set the source and binary directories to be the same. This is known as an in—source build, in contrast to an out—of—source build where they are different.

How to Run CMake? 11

 

CMake supports both in-source and out-of-source builds on all operating systems. This means that you can conﬁgure your build to be completely outside of the source code tree which makes it very easy to remove all of the ﬁles generated by a build. Having the build tree differ from the source tree also makes it easy to support having multiple builds of a single source tree. This is useful when you want to have multiple builds with different options but just one copy of the source code. Now let us consider the specifics of running CMake using its Qt based GUI and command line interfaces.

Running CMake’s Qt Interface

CMake includes a Qt based user interface developed by Clinton Stimpson that can be used on most platforms, including UNIX, Mac OS X, and Windows. This interface is included in the CMake source code, but you will need an installation of Qt on your system in order to build it.

 

File Tools Options Help

 

Where is the source code: ‘C:,I'Documents end SettingsJKeni'My DocumentsICh'iakefCMake . . 1 Browse ﬁource. ..]
Where to build the binaries: C:.I'DUCI.In'Ients and SettingsteniMy DocumentsilCI‘liakeiCMakeBin3 V Browse guild. ..
Search: in ,, ii i L l 7 ‘ gSimple View ' v1 43: add Entry _. gramme Entry

‘ Name

       

   

F‘ress Configure to update and display new values in red. then press Generate to generate selected build Files.

 

gonFigure generate Current Generator: Visual Studio 9 2008

lSearching 16 bit. integer A
Check size of misigned short:

lCheck size of unsigned short. - done

Using unsigned short.

‘Check if the system is big endian — little endian

Looking for elf.h

:Looking for elf.h - not found ,
Configuring done vi

 

 

 

Figure 1 — Qt based CMake GUI

On Windows the executable is named cmake—gui . exe and should be in your Start menu under Program Files. There may also be a shortcut on your desktop, or if you built CMake from source, it will be in the build directory. For UNIX and Mac users the executable is named cmake-gui and it can be found where you installed the CMake executables.A GUI will appear similar to what is shown in Figure l. The top two entries are the source code and binary directories. They allow you to specify where the source code is for What you want to compile and where the resulting binaries should be placed. You should set these two values ﬁrst. If the binary directory you specify does not exist, it will be created for you. If the binary directory has been conﬁgured by CMake before then it will automatically set the source tree.

The middle area is where you can specify different options for the build process. More obscure variables may be hidden, but can be seen if you select ”Advanced View" from the View pulldown. You can search for values in the middle area by typing all or part of the name into the Search box. This can be handy for ﬁnding speciﬁc settings or options in a large project. The bottom area of the window includes the Conﬁgure and Generate buttons as well as a progress bar and scrollable output window.

Once you have speciﬁed the source code and binary directories you should click the Conﬁgure button. This will cause CMake to read in the CMakeLists ﬁles from the source code directory and then update the cache area to display any new options for the project. If you are running cmake-gui for the ﬁrst time on this binary directory it will prompt you to determine what generator you wish to use, as shown in Figure 2. This dialog also presents options for customizing and tweaking the compilers you wish to use for this build.

mm

 

 

i' Llse default netiire compilers
Sp'cif';.-' native ccumpilers
L”? Specify tcicilcl'iain File for cress-cpmpiling

Specify cupticnns fer cress—ccumpiling

 

 

 

 

Figure 2 — Selecting a Generator

After the ﬁrst conﬁgure you can adjust your cache settings if desired and click the Conﬁgure button again. New values that were created by the conﬁgure process will be colored red. To be sure you have seen all possible values you should click Conﬁgure until no values are red and you are happy with all the settings. Once you are done conﬁguring, click the Generate button, this will produce the appropriate ﬁles.

It is important that you make sure that your environment is suitable for running cmake-gui. If you are using an IDE such as Visual Studio then your environment will be setup correctly for you If you are using NMake or MinGW then you need to make sure that the compiler can run from your environment. You can either directly set the required environment variables for your compiler or use a shell in which they are already set. For example, Microsoft Visual Studio has an option on the start menu for creating a Visual Studio Command Prompt. This opens up a command prompt window that has its environment already setup for Visual Studio. You should run cmake-gui from this command prompt if you want to use NMake Makeﬁles. The same approach applies to MinGW, you should run cmake-gui from a MinGW shell that has a working compiler in its path.

When cmake—gui ﬁnishes it will have generated the build ﬁles in the binary directory you speciﬁed. If Visual Studio was selected as the generator, a MSVC workspace (or solution) ﬁle is created. This ﬁle's name is based on the name of the project you speciﬁed in the PROJECT command at the beginning of your CMakeLists ﬁle. For many other generator types, Makeﬁles are generated. The next step in this process is to open the workspace with MSVC. Once open, the project can be built in the normal manner of Microsoft Visual C++. The ALL_BUILD target can be used to build all of the libraries and executables in the package. If you are using a Makeﬁle build type, then you would build by running make or nmake on the resulting Makeﬁles.

Running the ccmake Curses Interface

On most UNIX platforms, if the curses library is supported, CMake provides an executable called ccmake. This interface is a terminal-based text application that is very similar to the Qt based GUT. To run ccmake, change directory (Cd) to the directory where you want the binaries to be placed. This can be the same directory as the source code for what we call in—source builds or it can be a new directory you create. Then run ccmake with the path to the source directory on the command line. For in-source builds use "." for the source directory. This will start the text interface as shown in Figure 3 (in this case the cache variables are ﬁom VTK and most are set automatically).

14 Gettinq Started

'1Pﬂ'l' IEIILI‘T'f

-"TclTkE:im .i.b,"lj_btclE:.4g.so
e,a"ne\,relo;-KT r'I‘cl'l'kB e
50fbyarefnevel-JpchlchdiI: ib_.-”lj_'btk8 . 49'. so
-q - in=memcheck --leak-che=ck=pss --show-reac:hahle=yss --worka):ou.'nd.-_
.a’home , artdpfvt}: f’u‘T KDa ta
UN

 

Figure 3 — ccmake running on UNIX

Brief instructions are displayed in the bottom of the window. If you hit the "c" key, it will conﬁgure the project. You should always conﬁgure after changing values in the cache. To change values, use the arrow keys to select cache entries, and then the enter key to edit them. Boolean values will toggle with the enter key. Once you have set all the values as you like, you can hit the ”g" key to generate the Makeﬁles and exit. You can also hit "h" for help, "q" to quit, and "t" to toggle the Viewing of advanced cache entries. Two examples of CMake usage on the UNIX platform follow for a hello world project called Hello. In the ﬁrst example, an in-source build is performed.

Cd Hello
ccmake
make

In the second example, an out—of—source build is performed.

mkdir Hello—Linux
Cd Hello—Linux
ccmake ../HelIo
make

How to Run CMake? 15

Running CMake from the Command Line

From the command line, CMake can be run as an interactive question and answer session or as a non-interactive program. To run in interactive mode, just pass the "—i” option to CMake. This will cause CMake to ask you for a value for each entry in the cache file for the project. CMake will provide reasonable defaults, just like it does in the GUI and curses based interfaces. The process stops when there are no longer any more questions to ask. An example ofusing the interactive mode of CMake is provided below.

$ cmake -i eG "NMake Makefiles" ../CMake
Would you like to see advanced options? [No]:
Please wait while cmake processes CMakeLists.txt files....

Variable Name: BUILDiTESTING
Description: Build the testing tree.
Current Value: ON

New Value (Enter to keep current value):

Variable Name: CMAKE‘INSTALL PREFIX

Description: Install path prefix, prepended onto install
directories.

Current Value: C:/Program Files/CMake

New Value (Enter to keep current value):

Please wait while cmake processes CMakeLists.txt files....

CMake complete, run make to build project.

Using CMake to build a project in non-interactive mode is a simple process if the project has few or no options. For larger projects like VTK, using ccmake, cmake —i, or cmake—gui is recommended. To build a project with a non—interactive CMake, first change directory to where you want the binaries to be placed. For an in—source build you then run cmake . and pass in any options using the —D ﬂag. For out-of—source builds the process is the same except you run cmake and also provide the path to the source code as its argument. Then type make and your project should compile. Some projects will have install targets as well, you can type make install to install them.

Specifying the Compiler to CMake

On some systems you may have more than one compiler to choose from or your compiler may be in a non—standard place. In these cases you will need to specify to CMake where your desired compiler is located. There are three ways to specify this; the generator can specify the compiler, an environment variable can be set, or a cache entry can be set. Some generators are tied to a speciﬁc compiler, for example the Visual Studio 6 generator always uses the Microsoft Visual Studio 6 compiler. For Makeﬁle based generators CMake will try a list of usual compilers until it ﬁnds a working compiler. The list can be found in the ﬁles:

16 Gettinq Started



Modules/CMakeDeterminCCompiler . cmake and
Modules/CMakeDetermineCXXCompilei: . cmake

The lists can be preempted with environment variables that can be set before CMake is run. The CC environment variable speciﬁes the C compiler while CXX speciﬁes the C++ compiler. You can specify the compilers directly on the command line by using , DCMAKEgCXXiCOMPILER=cl for example. If those are not set, CMake will try the following list of compilers:

c++ g++ CC aCC cl bcc xlC.

Once CMake has been run and picked a compiler, you can change the selection by changing the cache entries CMAKE_CXX_COMPILER and CMAKE7C_COMPILER, although this is not recommended. The problem with doing this is that the project you are conﬁguring may have already run some tests on the compiler to determine what it supports. Changing the compiler does not normally cause these tests to be rerun which can lead to incorrect results. If you must change the compiler, start over with an empty binary directory. The ﬂags for the compiler and the linker can also be changed by setting environment variables. Setting LDFLAGS will initialize the cache values for link ﬂags, while CXXFLAGS and CFLAGS will initialize CMAKEgcxxieLAGs and CMAKE‘CiFLAGS respectively.

Dependency Analysis

CMake has powerful built-in dependency analysis capabilities for C and C++ source code ﬁles. CMake also has limited support for Fortran and Java dependencies. Since Integrated Development Environments (IDES) support and maintain dependency information, CMake skips this step for those build systems. However, Makeﬁles with a make program do not know how to automatically compute and keep dependency information up-to—date. For these builds, CMake automatically computes dependency information for C, C++ and Fortran ﬁles. Both the generation and maintenance of these dependencies are automatically done by CMake. Once a project is initially configured by CMake, users only need to run make, and CMake does the rest of the work. CMake’s dependencies fully support parallel builds for multiprocessor systems.

Although users do not need to know how CMake does this work, it may be useful to look at the dependency information ﬁles for a project. This information for each target is stored in four ﬁles called depend.make, flags.make, build.make, and Dependlnf0.cmake. depend.make stores the depend information for all the object ﬁles in the directory. flags . make contains the compile ﬂags used for the source ﬁles of this target. Ifthey change then the ﬁles will be recompiled. Dependlnfo.cmake is used to keep the dependency information up—to—date and contains information about what ﬁles are part of the project and what languages they are in. Finally, the rules for building the dependencies are stored in buildmake. If a dependency is out of date then all of the dependencies for that target will be recomputed, keeping the dependency information current.

2.6 Editing CMakeLists Files

CMakeLists ﬁles can be edited in almost any text editor. Some editors, such as Notepad++, come with CMake syntax highlighting and indentation support built in. For editors such as Emacs or Vim CMake includes indentation and syntax highlighting modes. These can be found in the Docs directory of the source distribution, or downloaded from the CMake web site. The ﬁle Cmake-mode.el is the Emacs mode, and cmake—indent.vim and cmake~ syntax . vim are used by Vim. Within Visual Studio the CMakeLists ﬁles are listed as part of the project and you can edit them simply by double clicking on them. Within any of the supported generators (Makeﬁles, Visual Studio, etc) if you edit a CMakeLists ﬁle and rebuild, there are rules that will automatically invoke CMake to update the generated ﬁles (eg. Makeﬁles or project ﬁles) as required. This helps to assure that your generated ﬁles are always in sync with your CMakeLists ﬁles.

Since CMake computes and maintains dependency information, the CMake executables must always be available (though they don’t have to be in your PATH) when make or an IDE is being run on CMake generated ﬁles. This means that if a CMake input ﬁle changes on disk, your build system will automatically re-run CMake and produce up-to-date build ﬁles. For this reason you generally should not generate Makeﬁles or projects with CMake and move them to another machine that does not have CMake installed.

2.7 Setting Initial Values for CMake

While CMake works well in an interactive mode, sometimes you will need to setup cache entries without running a GUI. This is common when setting up nightly dashboards or if you will be creating many build trees with the same cache values. In these cases the CMake cache can be initialized in two different ways. The ﬁrst way is to pass the cache values on the CMake command line using -DCACHE_VAR: TYPE=VALUE arguments. For example, consider the following nightly dashboard script for a UNIX machine:

#I/bin/tcsh
cd ${HOME}
# wipe out the old binary tree and then create it again

rm -rf Foo-Linux
mkdir Foo-Linux
cd Foo-Linux

# run cmake to setup the cache
cmake -DBUILD_TESTING:BOOL=ON <etc...> ../Foo

# generate the dashboard
ctest -D Nightly

The same idea can be used with a batch ﬁle on Windows. The second way is to create a ﬁle to be loaded using CMake's —C option. In this case instead of setting up the cache with -D options it is done though a ﬁle that is parsed by CMake. The syntax for this ﬁle is standard CMakeLists syntax and it is typically just a series of set commands such as:

#Build the vtkHybrid kit.
set (VTK_USE_HYBRID ON CACHE BOOL "doc string")

In some cases there might be an existing cache and you want to force the cache values to be set a certain way. For example say you want to turn Hybrid on even if the user has previously run CMake and turned it off. Then you can do:

#Build the vtkHybrid kit always.
set (VTKiUSE_HYBRID ON CACHE BOOL "doc" FORCE)

Another option is that you want to set and then hide options so the user will not be tempted to adjust them later on. This can be done using the following commands:

#Build the vtkHybrid kit always and don’t distract
#the user by showing the option.
set (VTK_USE_HYBRID ON CACHE INTERNAL "doc" FORCE)
markwas_advanced (VTK_USE_HYBRID)

You might be tempted to edit the cache ﬁle directly, or to "initialize" a project by giving it an initial cache ﬁle. This may not work and could cause additional problems in the future. First, the syntax of the CMake cache is subject to change. Second, cache ﬁles have full paths in them that make them unsuitable for moving between binary trees. So if you want to initialize a cache ﬁle use one of the two standard methods described above.

Buildigng Your Project 19

 

2.8 Building Your Project

After you have run CMake your project will be ready to be built. If your target generator is based on Makeﬁles then you can build your project by changing directory to your binary tree and typing make (or gmake or nmake as appropriate). If you generated ﬁles for an IDE such as Visual Studio, you can start your lDE, load the project ﬁles into it, and build as you normally would.

Another option is to use CMake’s ebuild option from the command line. This option is simply a convenience that allows you to build your project from the command line, even if that requires launching an IDE. The command line options for -build include:

Usage: cmake --build <dir> [options] [-- [native-options]]
Options:
<dir>		= Project binary directory to be built.

--target <tgt>	= Build <tgt> instead of default targets.
--config <cfg>	= For multi-configuration tools, choose <cfg>.
--clean-first	= Build target 'clean' first, then build.
		  (To clean only, use --target 'clean'.)
--		= Pass remaining options to the native tool.

So even if you are using Visual Studio as your generator you can type the following to build your project from the command line if you wish.

cmake ——build <your binary dir>

That is all there is to installing and running CMake for simple projects. In the following chapters we will consider CMake in more detail and how to use it on more complex software projects.

 

Chapter 3

 

Key Concepts

3.1 Main Structures

This chapter provides an introduction to CMake's key concepts. As you start working with CMake you will run into a variety of concepts such as targets, generators, and commands. In CMake these concepts are implemented as C++ classes and are referenced in many of CMake's commands. Understanding these concepts will provide you with the working knowledge you need to create effective CMakeLists ﬁles.

Before going into detail about CMake’s classes it is worth understanding their basic relationships. At the lowest level there are source files. These correspond to typical C or C++ source code files. Source files are combined into targets. A target is typically an executable or library. A directory represents a directory in the source tree and typically has a CMakeLists file and one or more targets associated with it. Every directory has a local generator that is responsible for generating the Makeﬁles or project ﬁles for that directory. All of the local generators share a common global generator that oversees the build process. Finally, the global generator is created and driven by the cmake class itself.

Figure 4 shows the basic class structure of CMake. We will now consider CMake's concepts in a bit more detail. CMake's execution begins by creating an instance of the cmake class and passing the command line arguments to it. This class manages the overall conﬁguration process and holds information that is global to the build process such as the cache values. One of the ﬁrst things the cmake class does is to create the correct global generator based on the user's selection of what generator to use (such as Visual Studio 10, Borland Makeﬁles, or UNIX Makefiles). At this point the cmake class passes control to the global generator it created by invoking the conﬁgure and generate methods.

22

 

cmake
0 controls the cmake process
0 can be created and used in
various GUIs

 

 

Has one

 

cmGlobalGenerator
- abstract base class
- child classes responsible for
platform—speciﬁc build process

 

 

 

Has many

v

 

 

 

cmLocalGenerator
o abstract base class
0 child classes responsible for
platform-speciﬁc build ﬁle

 

 

Key Concgats

cmGlobalUnixMakeﬁleGenerator
cmGlobalVisualStudioéGenerator
cmGlobalVisualStudi07Generat0r

Derive from

cmLocalUnixMakefileGenerator
cmLocalVisualStudi06Generator
cmLocalVisualStudi07Generat0r

Derive from

 

 

W

 

 

 

 

 

t'
genera 1on o abstract base class
0 child classes responsible for
implementing all commands in
Has one CMake.
it
cmMakefile .
0 Stores all of the information parsed Derive from
from a CMakeLists.txt ﬁle.
0 List of targets and variables cmRemoveCommand
0 Optional ﬂags cmSetCommand
- List of libraries cmAddTestCommand
0 List of include paths
0 Parses CMakeLists.txt ﬁles

 

 

Figure 4 - CMake Internals

Main Structures 23

 

The global generator is responsible for managing the conﬁguration and generation of all of the Makeﬁles (or project ﬁles) for a project. In practice most of the work is actually done by local generators which are created by the global generator One local generator is created for each directory of the project that is processed. So while a project will have only one global generator it may have many local generators. For example, under Visual Studio 7 the global generator creates a solution ﬁle for the entire project while the local generators create a project ﬁle for each target in their directory.

In the case of the "Unix Makeﬁles" generator, the local generators create most of the Makeﬁles and the global generator simply orchestrates the process and creates the main top-level Makeﬁle. Implementation details vary widely among generators. The Visual Studio 6 generators make use of .dsp and .dsw ﬁle templates and perform variable replacements on them. The generators for Visual Studio 7 and later directly generate the XML output without using any ﬁle templates. The Makeﬁle generators including UNIX, NMake, Borland, etc use a set of rule templates and replacements to generate their Makeﬁles.

Each local generator has an instance of the class cmMakeﬁle, cmMakeﬁle is where the results of parsing the CMakeLists ﬁles are stored. Speciﬁcally, for each directory in a project there will be a single cmMakeﬁle instance which is why the cmMakeﬁle class is often referred to as the directory. This is clearer for build systems that do not use Makeﬁles. That instance will hold all of the information from parsing that directory's CMakeLists ﬁle (see Figure 5). One way to think of the cmMakeﬁle class is as a structure that starts out initialized with a few variables from its parent directory, and is then ﬁlled in as the CMakeLists ﬁle is processed. Reading in the CMakeLists ﬁle is simply a matter of CMake executing the commands it ﬁnds in the order it encounters them.

Each command in CMake is implemented as a separate C++ class, and has two main parts. The ﬁrst part of a command is the InitialPass method. The lnitialPass method receives the arguments and the cmMakef ile instance for the directory currently being processed, and then performs its operations. In the case of the set command, it processes its arguments and if the arguments are correct it calls a method on the cmMa kefile to set the variable. The results of the command are always stored in the cmMakefile instance. Information is never stored in a command. The last part of a command is the FinalPass. The FinalPass of a command is executed after all commands (for the entire CMake project) have had their InitialPass invoked. Most commands do not have a FinalPass, but in some rare cases a command must do something with global information that may not be available during the initial pass.

Once all of the CMakeLists ﬁles have been processed the generators use the information collected into the cmMakefile instances to produce the appropriate ﬁles for the target build system (such as Makeﬁles).

3.2 Targets

Now that we have discussed the overall process of CMake, let us consider some of the key items stored in the cmMakefile instance. Probably the most important item is targets. Targets represent executables, libraries, and utilities built by CMake. Every addil ibrary, adol‘executable, and add_custom_target command creates a target. For example, the following command will create a target named foo that is a static library, with foo1.c and foo2.c as source ﬁles.

addilibrary (foo STATIC fool.c fooZ.c)

The name foo is now available for use as a library name everywhere else in the project, and CMake will know how to expand the name into the library when needed. Libraries can be declared to be of a particular type such as STATIC, SHARED, MODULE, or left undeclared. STATIC indicates that the library must be built as a static library. Likewise SHARED indicates it must be built as a shared library. MODULE indicates that the library must be created so that it can be dynamically loaded into an executable. On many operating systems this is the same as SHARED, but on other systems such as Mac OS X it is different. If none of these options are speciﬁed this indicates that the library could be built as either shared or static. In that case CMake uses the setting of the variable BU ILDpSHAREDiLIBS to determine if the library should be SHARED or STATIC. If it is not set, then CMake defaults to building static libraries.

Likewise executables have some options. By default an executable will be a traditional console application that has a main (int argc, const char*argv[] ). If WTN32 is speciﬁed after the executable name then the executable will be compiled as a MS Windows executable and the operating system will call WinMain instead of main at startup. WIN32 has no effect on non-Windows systems.

In addition to storing their type, targets also keep track of general properties. These properties can be set and retrieved using the setitarget_properties and get’target_property commands, or the more general set_property and getiproperty commands. The most commonly used property is LINK_FLAGS, which is used to specify link ﬂags for a speciﬁc target. Targets store a list of libraries that they link against which are set using the targetilinkilibraries command. Names passed into this command can be libraries, full paths to libraries, or the name of a library from an add_l ibrary command. They also store the link directories to use when linking, the install location for the target, and custom commands to execute after linking.

For each library CMake creates, it keeps track of all the libraries on which that library depends. Since static libraries do not link to the libraries on which they depend, it is important for CMake to keep track of the libraries so they can be speciﬁed on the link line of the executable being created. For example,

add‘library (foo foo.cxx)
target‘linkﬁlibraries (foo bar)

addiexecutable (foobar foobar.cxx)
target_link_libraries (foobar foo)

This will link the libraries foo and bar into the executable foobar even, although only foo was explicitly linked into foobar. With shared or DLL builds this linking is not always needed, but the extra linkage is harmless. For static builds this is required. Since the foo library uses symbols from the bar library, foobar will most likely also need bar since it uses foo.

3.3 Source Files

The source ﬁle structure is in many ways similar to a target. It stores the ﬁlename, extension, and a number of general properties related to a source ﬁle. Like targets you can set and get properties using set_source_files_properties and get_source_file_property, or the more generic versions. The most common properties include:

COMPILE_FLAGS

Compile ﬂags speciﬁc to this source ﬁle. These can include source speciﬁc eD and , I ﬂags.

GENERATED

The GENERATED property indicates that the source ﬁle is generated as part of the build process. In this case CMake will treat it differently for computation of dependencies because the source ﬁle may not exist when CMake is ﬁrst run.

OBJECT_DEPENDS

Adds additional ﬁles on which this source ﬁle should depend. CMake automatically performs dependency analysis to determine the usual C, C++ and Fortran dependencies, This parameter is used rarely in cases where there is an unconventional dependency or the source ﬁles do not exist at dependency analysis time.

ABSTRACT
WRAP_EXCLUDE

CMake doesn't directly use these properties. Some loaded commands and extensions to CMake look at these properties to determine how and when to wrap a C++ class into languages such as Tcl, Python, etc.

3.4 Directories, Generators, Tests, and Properties

in addition to targets and source ﬁles you may ﬁnd yourself occasionally working with other classes such as directories, generators, and tests. Normally such interactions take the shape of setting or getting properties from these objects. All of these Classes have properties associated with them, as do source ﬁles and targets. A property is a key—value pair attached to a speciﬁc object such as a target. The most generic way to access properties is through the setgproperty and getip roperty commands. These commands allow you to set or get a property from any class in CMake that has properties. Some of the properties for targets and source ﬁles have already been covered. Some useful properties for a directory include:

ADDITIONAL_MAKE_CLEAN_FILES

This property speciﬁes a list of additional ﬁles that will be cleaned as a part of the "make clean" stage. By default CMake will clean up any generated ﬁles that it knows about, but your build process may use other tools that leave ﬁles behind. This property can be set to a list of those ﬁles so that they also will be properly cleaned up.

EXCLUDE_FROM_ALL
This property indicates if all the targets in this directory and all sub directories should be excluded from the default build target. Ifit is not, then with a Makeﬁle for example typing make will cause these targets to be built as well. The same concept applies to the default build of other generators.

LISTFILE_STACK

This property is mainly useful when trying to debug errors in your CMake scripts. It returns a list of what list ﬁles are currently being processed, in order. So if one CMakeLists ﬁle does an include command then that is effectively pushing the included CMakeLists ﬁle onto the stack.

Variables and Cache Entries 27

 

A full list of properties supported in CMake can be obtained by running cmake with the --help—property—list option. The generators and directories are automatically created for you as CMake processes your source tree.

3.5 Variables and Cache Entries

CMakeLists files use variables much like any programming language. Variables are used to store values for later use, and can be a single value such as "ON" or "OFF", or they can represent a list such as(/usr/include /home/foo/include /usr/local/include). A number of useful variables are automatically deﬁned by CMake and are discussed in Appendix A - Variables.

Variables in CMake are referenced using a ${VARIABLE} notation, and they are deﬁned in the order of execution of the set commands. Consider the following example:

# FOO is undefined

set (FOO l)
# FOO is now set to 1

set (FOO O)
# FOO is now set to O

This may seem straightforward, but consider the following example:

set (FOO 1)

if (${FOO} LESS 2)

set (FOO 2)
else (${FOO} LESS 2)
set (FOO 3)

endif ($lFOO} LESS 2)

Clearly the if statement is true, which means that the body of the if statement will be executed. That will set the variable FOO to 2, and so when the else statement is encountered FOO will have a value of 2. Normally in CMake the new value of FOO would be used, but the else statement is a rare exception to the rule and always refers back to the value of the variable when the if statement was executed. So in this case the body of the else clause will not be executed. To further understand the scope of variables consider this example:

28 Kgy Concepts

 

set (foo 1)

it process the dirl subdirectory
addisubdirectory (dirl)

# include and process the commands in filel.cmake
include <filel.cmake)

set (bar 2)
# process the dir2 subdirectory
ladd/subdirectory (dir2)

# include and process the commands in file2.cmake
include (file2.cmake)

In this example because the variable foo is deﬁned at the beginning, it will be deﬁned while
processing both dirl and dir2. In contrast bar will only be deﬁned when processing dir2.
Likewise foo will be deﬁned when processing both ﬁlel.cmake and ﬁle2.cmake, whereas
bar will only be deﬁned while processing ﬁle2.cmake.

Variables in CMake have a scope that is a little different from most languages. When you set
a variable it is visible to the current CMakeLists ﬁle or function, as well as any subdirectory’s
CMakeLists ﬁles, any functions or macros that are invoked, and any ﬁles that are included
using the INCLUDE command. When a new subdirectory is processed (or a function called) a
new variable scope is created and initialized with the current value of all variables in the
calling scope. Any new variables created in the child scope, or changes made to existing
variables, will not impact the parent scope. Consider the following example:

function (foo)

message ($ltest}) it test is 1 here

set (test 2)

message (${test}) it test is 2 here, but only in this scope
endfunction()

set (test 1)
_foo()
message (${test}) # test will still be 1 here

In some cases you might want a function or subdirectory to set a variable in its parent’s scope. This is one way for CMake to return a value from a function, and it can be done by using the PARENT #SCOPE option with the set command. We can modify the prior example so that the function foo changes the value of test in its parent’s scope as follows:

Variables and Cache Entries 29

 

function (foo)

message (${testl) # test is 1 here

Set (test 2 PARENTﬁSCOPE)

message (${test}) # test still 1 in this scope
endfunction()

set (test 1)
‘ foo()
message (${testl) it test will now be 2 here

Variables can also represent a list of values. In these cases when the variable is expanded it will be expanded into multiple values. Consider the following example:

# set a list of items
set (items/torbuy apple orange pear beer)

# loop over the items
foreach (item ${itemsitoibuy})

message ( "Don’t forget to buy one ${item}" )
endforeach ()

In some cases you might want to allow the user building your project to set a variable from
the CMake user interface. In that case the variable must be a cache entry. Whenever CMake is
run it produces a cache file in the directory where the binary ﬁles are to be written. The values
ofthis cache file are displayed by the CMake user interface. There are a few purposes of this
cache. The first is to store the user's selections and choices, so that if they should run CMake
again they will not need to reenter that information. For example, the option command
creates a Boolean variable and stores it in the cache.

option (USEiJPEG "Do you want to use the jpeg library")

The above line would create a variable called USEiJ PEG and put it into the cache. That way
the user can set that variable from the user interface and its value will remain in case the user
should run CMake again in the future. To create a variable in the cache you can use
commands like option, findifile, or you can use the standard set command with the
CACHE option.

set (USEiJPEG ON CACHE BOOL "include jpeg support?")

When you use the cache option you must also provide the type of the variable and a
documentation string. The type of the variable is used by the GUI to control how that variable

30 Key Concepts

is set and displayed. Variable types include BOOL, PATH, FILEPATH, and STRING. The
documentation string is used by the GUI to provide online help.

The other purpose of the cache is to store key variables that are expensive to determine. These
variables may not be Visible or adjustable by the user. Typically these values are system
dependent variables such as CMAKEVWORDSiBIGENDIAN, which require CMake to compile
and run a program to determine their value. Once these values have been determined, they are
stored in the cache to avoid having to recompute them every time CMake is run. Generally
CMake tries to limit these variables to properties that should never change (such as the byte
order of the machine you are on). If you signiﬁcantly change your computer, either by
changing the operating system, or switching to a different compiler, you will need to delete
the cache ﬁle (and probably all of your binary tree's object ﬁles, libraries, and executables).

Variables that are in the cache also have a property indicating if they are advanced or not. By
default when a CMake GUI is run (such as ccmake or cmake—gui) the advanced cache entries
are not displayed. This is so that the user can focus on the cache entries that they should
consider changing. The advanced cache entries are other options that the user can modify, but
typically will not. It is not unusual for a large software project to have ﬁfty or more options,
and the advanced property lets a software project divide them into key options for most users
and advanced options for advanced users. Depending on the project there may not be any non-
advanced cache entries. To make a cache entry advanced the mark‘as_advanced command
is used with the name of the variable (a.k.a. cache entry) to make advanced.

In some cases you might want to restrict a cache entry to a limited set ofpredeﬁned options.
You can do this by setting the STRINGS property on the cache entry. The following
CMakeLists code illustrates this by creating a property named CRY PTOBACKEN D as usual, and
then setting the STRINGS property on it to a set of three options.

set (CRYPTOBACKEND "OpenSSL" CACHE STRING
"Select a cryptography backend")
setiproperty (CACHE CRYPTOBACKEND PROPERTY STRINGS
"OpenSSL" "LibTomCrypt" "LibDES")

When cmake-gui is run and the user selects the CRYPTOBACKEND cache entry, they will be
presented with a pulldown to select which option they want, as shown in Figure 6.

Variables and Cache Entries 31

 

 

File Tools Options Help

Where is the source code: ftli‘DUClJrl'lentﬁ and Settingsteni’rviy Docurnentsi‘Cl‘tlaieiTest , 4 _ [Browse Source...
Where to build the binaries: l C:,I'Do_cunien_ts and’Settingsi'KeniMy rournentsICMakeITest i i l v L Browse Build...
Search; A ‘ I _ i , E {Sirnpleiti'iew v [$5 Add Entry I or Remove Entry
Name ,, ,. ,, ,, ,, , .. value

iCMAKE_BACKU.’RRDS_COMPATIBILITY 2.4

   
   

CMAK INTA :iProgram Filesi'Proiect

  

    
    

EXECUTRBLE_OUTPUT_PTH
:LIBR AR‘r'_OU'l'F'LIT_Pi'J.TH
LibDES ,

 

Press Configure to update and display new values in red, then press Generate to generate selected build Files.

l Configure Generate Current Generator: Visual Studio 9 2008 l J

C on f i gur 111g done

 

 

 

Figure 6 — Cache Value Options in cmake-gui

A few ﬁnal points should be made concerning variables and their interaction with the cache.
If a variable is in the cache, it can still be overridden in a CMakeLists ﬁle using the set
command without the CACHE option. Cache values are checked only if the variable is not
found in the current cmMakefile instance before CMakeLists ﬁle processing begins. The
set command will set the variable for processing the current CMakeLists ﬁle (and
subdirectories as usual) without changing the value in the cache.

# assume that FOO is set to ON in the cache

set (FOO OFF)
# sets foo to OFF for processing this CMakeLists file
# and subdirectories; the value in the cache stays ON

Once a variable is in the cache, its ”cache" value cannot normally be modiﬁed from a
CMakeLists ﬁle. The reasoning behind this is that once CMake has put the variable into the
cache with its initial value, the user may then modify that value from the GUI. If the next
invocation of CMake overwrote their change back to the set value, the user would never be
able to make a change that CMake wouldn’t overwrite. So a set (FOO ON CACHE BOOL
"cloc") command will typically only do something when the cache doesn‘t have the variable
in it. Once the variable is in the cache, that command will have no effect.

32 Key Concepts

 

In the rare event that you really want to change a cached variable's value you can use the
FORCE option in combination with the CACHE option to the set command. The FORCE option
will cause the set command to override and change the cache value ofa variable.

3.6 Build Configurations

Build conﬁgurations allow a project to be built in different ways for debug, optimized, or any

other special set of ﬂags. CMake supports, by default, Debug, Release, MinSizeRel, and
RelWithDeblnfo conﬁgurations. Debug has the basic debug ﬂags turned on. Release has the
basic optimizations turned on. MinSizeRel has the ﬂags that produce the smallest object code,
but not necessarily the fastest code. RelWithDebInfo builds an optimized build with debug
information as well.

CMake handles the conﬁgurations in slightly different ways depending on what generator is
being used. The conventions of the native build system are followed when possible. This
means that conﬁgurations impact the build in different ways when using Makeﬁles versus
using Visual Studio project ﬁles.

The Visual Studio IDE supports the notion of Build Conﬁgurations. A default project in
Visual Studio usually has Debug and Release conﬁgurations. From the IDE you can select
build Debug, and the ﬁles will be built with Debug ﬂags. The IDE puts all of the binary ﬁles
into directories with the name of the active conﬁguration. This brings about an extra
complexity for projects that build programs that need to be run as part of the build process
from custom commands. See the CMAKE_CEG_INTDIR variable and the custom commands
section for more information about how to handle this issue. The variable
CMAKE_CONFIGURATION_TYPES is used to tell CMake which conﬁgurations to put in the
workspace.

With Makeﬁle based generators, only one conﬁguration can be active at the time CMake is
run, and it is speciﬁed by the CMAKEWBUILDHTYPE variable. if the variable is empty then no
ﬂags are added to the build. If the variable is set to the name of a conﬁguration, then the
appropriate variables and rules (such as CMAKEWCXX>FLAGS_<COnfigName>) are added to
the compile lines. Makeﬁles do not use special conﬁguration subdirectories for object ﬁles.
To build both debug and release trees, the user is expected to create multiple build directories
using the out of source build feature of CMake, and to set the CMAKEiBUILDiTYPE to the
desired selection for each build. For example,

it With source code in the directory MyProject

it to build MyProject—debug create that directory, cd into it and
(ccmake ../MyProject «DCMAKEJBUILDWTYPE:STRING=Debug)

it the same idea is used for the release tree MyProject—release
(ccmake ../MyProject vDCMAKE~BUILD_TYPE:STRING:Release)

CMake Syntax 33

 

Writing CMakeLists Files

This chapter will cover the basics of writing effective CMakeLists ﬁles for your software. It
will cover all of the basic commands and issues you will need to handle most projects. It will
also discuss how to convert existing UNIX or Windows projects into CMakeLists ﬁles. While
CMake can handle extremely complex projects, for most projects you will ﬁnd this chapter’s
contents will tell you all you need to know. CMake is driven by the CMakeLists.txt ﬁles
written for a software project. The CMakeLists ﬁles determine everything from what options
to put into the cache, to what source ﬁles to compile. ln addition to discussing how to write a
CMakeLists ﬁle this chapter will also cover how to make them robust and maintainable. The
basic syntax of a CMakeLists.txt ﬁle and key concepts of CMake have already been discussed
in chapters 2 and 3. This chapter will expand on those concepts and introduce a few new ones.

4.1 CMake Syntax

CMakeLists ﬁles follow a simple syntax consisting of comments, commands, and white
space. A comment is indicated using the # character and runs from that character until the end
of the line. A command consists of the command name, opening parenthesis, white space
separated arguments and a closing parenthesis. All white space (spaces, line feeds, tabs) are
ignored except to separate arguments. Anything within a set of double quotes is treated as one
argument as is typical for most languages. The backslash can be used to escape characters
preventing the normal interpretation of them. The subsequent examples in this chapter will
help to clear up some of these syntactic issues. You might wonder why CMake decided to
have its own language instead of using an existing one such as Python, Java, or Tcl. The main
reason is that we did not want to make CMake require an additional tool to run. By requiring
one of these other languages all users of CMake would be required to have that language
installed, and potentially a speciﬁc version of that language. This is on top of the language

34 Writinq CMakeLists Files

extensions that would be required to do some of the CMake work, for both performance and
capability reasons.

4.2 Basic Commands

While the previous chapters have already introduced many of the basic commands for
CMakeLists ﬁles, this chapter will review and expand on them. The ﬁrst command the top-
level CMakeLists ﬁle should have is the PROJECT command. This command both names the
project and optionally speciﬁes what languages will be used by it. Its syntax is as follows:

project (projectname [CXX] [C] [Java] [NONE])

If no languages are speciﬁed then CMake defaults to supporting C and C++. If the NONE
language is passed then CMake includes no language speciﬁc support. Whenever C++
language support is speciﬁed then C language support will also be loaded

For each project command that appears in a project, CMake will create a top level IDE project
ﬁle. The project will contain all targets that are in the CMakeLists.txt ﬁle, and any of its
subdirectories as speciﬁed by the addis ubdi recto ry command. If the
EXCLUDEiFROM_ALL option is used in the addisubdi rectory command, then the
generated project will not appear in the top level Makeﬁle or IDE project ﬁle. This is useful
for generating sub projects that do not make sense as part of the main build process. Consider
that a project with a number of examples could use this feature to generate the build ﬁles for
each example with one run of CMake, but not have the examples built as part of the normal
build process.

The set command is probably one of the most used commands since it is used for deﬁning
and modifying variables and lists. Complimenting the set command are the remove and
separate_arguments commands. The remove command can be used to remove a value
from a variable list, while the separatemarguments command can be used to take a single
variable value (as opposed to a list) and break it into a list based on spaces.

The addiexecutable and add‘library commands are the main commands for deﬁning
what libraries and executables to build, and what source ﬁles comprise them. For Visual
Studio projects the source ﬁles will show up in the IDE as usual, but any header ﬁles the
project uses will not be there. To have the header ﬁles show up as well you simply add them
to the list of source ﬁles for the executable or library. This can be done for all generators. Any
generators that do not use the header ﬁles directly (such as Makeﬁle based generators) will
simply ignore them.

Flow Control 35

4.3 Flow Control

In many ways writing a CMakeLists ﬁle is like a writing a program in a simple language.
Like most languages CMake provides ﬂow control structures to help you along your way.
CMake provides three ﬂow control structures;

0 conditional statements (e.g. if)
- looping constructs (e.g. foreach and while)
0 procedure deﬁnitions (e.g. macro and function)

First we will consider the if command. In many ways the if command in CMake isjust like
the if command in any other language. It evaluates its expression and based on that either
executes the code in its body or optionally the code in the else clause. For example:

if (FOO)

# do something here
else (FOO)

# do something else
endif (FOO)

One difference you might notice is that the conditional of the if statement is repeated in the
else and endif clauses. This is optional and in this book you will see examples of both
styles. You could just as well choose to write:

if (FOO)

# do something here
else ()

# do something else
endif 0

When you include conditionals in the else and endif clause they are used to provide
additional error checking. As such they must exactly match the original conditional of the if
statement. The following code would not work:

set (FOO l)

if (${FOO})
# do something
endif (l)
# ERROR, it doesn't match the original if conditional

36 Writinq CMakeLists Files

Fortunately CMake provides verbose error messages in the case where an if statement is not
properly matched with an endif. This should help you to track down any problems with
matching conditionals. Providing the conditionals on the else and endif commands also has
the added beneﬁt of helping to document your CMakeLists ﬁle. With a long if statement it
can be easy to lose track of what if statement the endif is closing. if statements can be
nested to any depth, and any command can be used inside of an i f or else clause.

As with many other languages, CMake supports elseif so that you can sequentially test for
multiple conditions. For example:

if (MSVCSO)

# do something here
elseif (MSVC90)

# do something else
elseif (APPLE)

# do something else
endif ()

The if command has a limited set of operations that you can use. It does not support general
purpose C style expressions such as $ {FOO} & & $ { BAR} I l s { FUBAR}, instead it supports
a limited subset of expressions that should work for most cases. Speciﬁcally if supports:
if (variable)

True ifthe variable‘s value is not empty, 0, FALSE, OFF, or NOTFOUND.

if (NOT variable)
True ifthe variable‘s value is empty, 0, FALSE, OFF, 0r NOTFOUND

if (variablel AND variable2)
True if both variables would be considered true individually.

if (variablel OR variableZ)

True if either variable would be considered true individually.

if (COMMAND command—name)

True if the given name is a command that can be invoked.

if (DEFINED variable)

True if the given variable has been set, regardless of what value it was set to.

Flow Control 37

if (EXISTS ﬁle-name)
if (EXISTS directory-name)
True if the named ﬁle or directory exists.

if (IS_DIRECTORY name)
if (IS_ABSOLUTE name)
True if the given name is a directory, or absolute path respectively.

if (namel IS_NEWER_THAN namel)

True if the ﬁle speciﬁed by namel has a more recent modiﬁcation time than the ﬁle
speciﬁed by name2.

if (variable MATCHES regex)
if (string MATCHES regex)

True if the given string or variable's value matches the given regular expression.

Options such as EQUAL, LESS, and GREATER are available for numeric comparisons.
STRLESS, STREQUAL, and STRGREATER can be used for lexicographic comparisons.
VERSION_LESS, VERSION_EQUAL, and VERSIONiGREATER can be used to compare versions
of the form major [ .minor[ .patch [ . tweak] ] 1. Similar to C and C++ these expressions
can be combined to create more powerful conditionals. For example consider the following
conditionals:

if ((1 LESS 2) AND (3 LESS 4))
message ("sequence of numbers")
endif 0

if (1 AND 3 AND 4)
message ("series of true values")
endif (1 AND 3 AND 4)

if (NOT 0 AND 3 AND 4)
message ("a false value")
endif (NOT 0 AND 3 AND 4)

if (0 OR 3 AND 4)
message ("or statements")
endif (0 OR 3 AND 4)

if (EXISTS ${PROJECTiSOURCEiDIR}/Help.txt AND COMMAND IF)
message ("Help exists")
endif (EXISTS $lPROJECTiSOURCEiDIR}/Help.txt AND COMMAND IF)

38 WrithQ CMakeLists Files

 

set (fooba 0)

if (NOT DEFINED foobar)
message ("foobar is not defined")
endif (NOT DEFINED foobar)

if (NOT DEFINED fooba)
message ("fooba not defined")
endif (NOT DEFINED fooba)

In compound if statements there is an order of precedence that specifies the order that the
operations will be evaluated. For example, in the statement below, the NOT will be evaluated
ﬁrst then the AND, not the other way around. Thus the statement will be false and the message
never printed. Had the AND been evaluated ﬁrst the statement would be true.

if (NOT 0 AND 0)
message ("This line is never executed")
endif (NOT 0 AND O)

CMake deﬁnes the order of operations such that parenthetical groups are evaluated ﬁrst, then
EXISTS, COMMAND, DEFINED and similar preﬁx operators are evaluated, then any EQUAL,
LESS, GREATER, STREQUAL, STRLESS, STRGREATER, and MATCHES operators. The NOT
operators are evaluated next, and ﬁnally the AND and OR expressions will be evaluated. With
operations that have the same level of precedence, such as AND and OR, they will be evaluated
from left to right. Once all of the expressions have been evaluated the ﬁnal result will be
tested to see if it is true or false. CMake considers any of the following values to be true: ON,
I, YES, TRUE, Y. The following values are all considered to be false: OFF, 0, NO, FALSE, N,
NOTEOUND, *—NOTFOUND, IGNORE. This test is case insensitive so true, True, and TRUE are
all treated the same.

Now let us consider the other ﬂow control commands. The foreach, while, macro, and
function commands are the best way to reduce the size of your CMakeLists ﬁles and keep
them maintainable. The foreach command enables you to execute a group of CMake
commands repeatedly on the members of a list. Consider the following example adapted from
VTK:

foreach (tfile
TestAnisotropicDiffusion2D
TestButterworthLowPass
TestButterworthHighPass
TestCityBIockDistance

Flow Control 39

TestConvolve
)
additest(${tfile}—image ${VTK7EXECUTABLE}
${VTKfSOURCE_DIR}/Tests/rtlmageTest.tcl
${VTKgSOURCE_DIR}/Tests/${tflle}.tcl
—D ${VTKrDATADROOT}
-V Baseline/Imaging/${tfile}.png
—A ${VTKkSOURCEngR}/Wrapping/Tcl
)
endforeach ( tfile )

The ﬁrst argument of the f o reach command is the name of the variable that will take on a
different value with each iteration of the loop. The remaining arguments are the list of values
over which to loop. In this example the body of the foreach loop is just one CMake
command, add_test. In the body ofthe foreach loop any time the loop variable (tfile in
this example) is referenced it will be replaced with the current value from the list. In the ﬁrst
iteration, occurrences of $ { tfile} will be replaced with TestAnisotropicDiffusionZD.
In the next iteration, $ { tfile} will be replaced with TestButterworthLowPass. The
f o reach loop will continue to loop until all of the arguments have been processed.

It is worth mentioning that f oreach loops can be nested and that the loop variable is replaced
prior to any other variable expansion. This means that in the body of a foreach loop you
can construct variable names using the loop variable. In the code below the loop variable
tfile is expanded, and then concatenated with _TEST*RESULT. That new variable name is
then expanded and tested to see if it matches FAILED.

if ($i${tfile}lﬂTEST#RESULT} MATCHES FAILED)
message ("Test ${tfile} failed.")
endif 0

The while command provides for looping based on a test condition. The format for the test
expression in the while command is the same as that for the if command described earlier.
Consider the following example, which is used by CTest. Note that CTest updates the value of
CTESTfELAPSEDﬁTIME internally.

#####################################################

# run paraview and ctest test dashboards for 6 hours

#

while (${CTEST7ELAPSED7TIME} LEss 36000)
set (START#TIME ${CTEST7ELAPSED7TIMEH
ctestiruniscript ( "dashliParaViewivs7lcontinuous.cmake" )
ctestirun_script ( "dashlicmakeivs7lcontinuous.cmake" )

4O Writinq CMakeLists Files

endwhile ()

The foreach and while commands allow you to handle repetitive tasks that occur in
sequence, whereas the macro and function commands support repetitive tasks that may be
scattered throughout your CMakeLists ﬁles. Once a macro or function is deﬁned it can be
used by any CMakeLists ﬁles processed after its deﬁnition.

A function in CMake is very much like a function in C or C++. You can pass arguments into
it, and the arguments passed in become variables within the function. Likewise some standard
variables such as ARGC, ARGV, ARGN, and ARGVO, ARGVi, etc are deﬁned. Within a function
you are in a new variable scope, much like when you drop into a subdirectory using the
addisubdirectory command you are in a new variable scope. All the variables that were
deﬁned when the function was called are still deﬁned, but any changes to variables or new
variables only exist within the function. When the function returns those variables will go
away. Put more simply, when you invoke a function a new variable scope is pushed and when
it returns that variable scope is popped.

The ﬁrst argument is the name of the function to deﬁne. All additional arguments are formal
parameters to the function.

function(DetermineTime itime)
# pass the result up to whatever invoked this
set (${rtime} “1:23:45” PARENTfSCOPE)
endfunction()

# now use the function we just defined
DetermineTime( currentVtime )

if( DEFINED currentitime )
message(STATUS "The time is now: ${Curretitime}")
endifﬂ

Note that in this example itime is used to pass the name of the return variable. The set
command is invoked with the value ofitime, which in this example will be Currentitime.
Finally the set command uses the PARENTiSCOPE option to set that variable in the parent’s
scope instead of the local scope.

Macros are deﬁned and called in the same manner as ﬁanctions. The main differences are that
a macro does not push and pop a new variable scope, and the arguments to a macro are not
treated as variables but are string replaced prior to execution. This is very much like the
differences between a macro and a function in C or C++. The ﬁrst argument is the name of
the macro to create. All additional arguments are formal parameters to the macro[.

How/Connol 41

# define a simple macro

macro (assert TEST COMMENT)
if (NOT ${TEST))
message ("Assertion failed: ${COMMENT}”)
endif (NOT ${TEST})
endmacro (assert)

# use the macro
findilibrary (FOOiLIB foo /usr/local/lib)
assert ( ${FOOiLIB) "Unable to find library foo" )

The simple example above creates a macro called assert. The macro is deﬁned to take two
arguments. The ﬁrst argument is a value to test and the second argument is a comment to print
out if the test fails. The body of the macro is a simple if command with a message
command inside of it. The macro body ends when the endmacro command is found. The
macro can be invoked simply by using its name as if it were a command. In the above
example if FOOiLIB was not found a message would be displayed indicating the error

condition.

The macro command also supports deﬁning macros that take variable argument lists. This
can be useful if you want to deﬁne a macro that has optional arguments or multiple signatures.
Variable arguments can be referenced using ARGC and ARGVO, ARGVT, etc., instead of the
formal parameters. ARGVO represents the ﬁrst argument to the macro, ARGVl represents the
next, and so forth. You can even use a mixture of formal arguments and variable arguments,
as shown in the example below.

# define a macro that takes at least two arguments
# (the formal arguments) plus an optional third argument

macro (assert TEST COMMENT)
if (NOT ${TEST})
message ("Assertion failed: ${COMMENT}")

# if called with three arguments then also write the
# message to a file specified as the third argument
if (${ARGC} MATCHES 3)
file (APPEND ${ARGV2} "Assertion failed: ${COMMENT}")
endif (${ARGC} MATCHES 3)

endif (NOT ${TEST})
endmacro (ASSERT)

42 Wri'tinq CMakeLists Files

it use the macro
findplibrary (FOOiLIB foo /usr/local/lib)
assert ( ${FOOiLIB} "Unable to find library foo" )

In this example the two required arguments are TEST and COMMENT. These required
arguments can be referenced by name, as they are in this example, or they can be referenced
‘using ARGVO and ARGVT. If you want to process the arguments as a list you can use the ARGV
and ARGN variables. ARGV (as opposed to ARGVO, ARGVl, etc) is a list of all the arguments to
the macro, while ARGN is a list of all the arguments after the formal arguments. Inside your
macro you can use the f oreach command to iterate over ARGV or ARGN as desired.

CMake has two commands for interrupting the processing flow. The break command will
break out ofa foreach or while loop before it would normally end. The return command
will return from a function or listﬁle before the function or listfile has reached its end.

4.4 Regular Expressions

A few CMake commands, such as if and string, make use of regular expressions, or can
take a regular expression as an argument. In its simplest form, a regular—expression is a
sequence of characters used to search for exact character matches. However, many times the
exact sequence to be found is not known, or only a match at the beginning or end of a string is
desired. Since there are several different conventions for specifying regular expressions
CMake’s standard is described below. The description is based on the open source regular
expression class from Texas Instruments, which is used by CMake for parsing regular
expressions.

Regular expressions can be speciﬁed by using combinations of standard alphanumeric
characters and the following regular expression meta-characters:

A Matches at beginning of a line or string.
$ Matches at end of a line or string.
Matches any single character other than a newline.
[ ] Matches any character(s) inside the brackets.
[A ] Matches any character(s) not inside the brackets.

[-] Matches any character in range on either side of a dash.

Matches preceding pattern zero or more times.

Rggular Expressions 43

 

+ Matches preceding pattern one or more times.
? Matches preceding pattern zero or once only.
0 Saves a matched expression and uses it in a later replacement.

( I ) Matches either the left or right side of the bar.

Note that more than one of these meta-characters can be used in a single regular expression in
order to create complex search patterns. For example, the pattern [Aabl—9] indicates to match
H 97

any character sequence that does not begin with the characters a or “b" or numbers in the
series one through nine. The following examples may help clarify regular expression usage:

0 The regular expression ”Ahello" matches a "hello" only at the beginning of a search
string. It would match "hello there", but not ”hi,\nhello there".

I The regular expression "long$" matches a "long" only at the end of a search string. It
would match "so long", but not "long ago".

0 The regular expression "t..t..g” will match anything that has a "t”, then any two
H H

characters, another "t", any two characters, and then a g . It would match "testing" or
"test again", but would not match "toasting".

o The regular expression "[l-9ab]" matches any number one through nine, and the
characters "a" and "b". It would match "hello 1" or "begin", but would not match "no-
match”.

0 The regular expression "[Al—9ab]" matches any character that is not a number one
through nine, or an "a" or "b”. It would NOT match "lab2" or "b2345a", but would
match "no—match".

o The regular expression "br* " matches something that begins with a "b", is followed by
zero or more "r"s, and ends in a space. It would match "brrrrr " and "b ", but would not
match "brrh ".

o The regular expression "br+ " matches something that begins with a "b", is followed by
one or more "r"s, and ends in a space. It would match "brrrrr ", and "br ", but would not
match "b " or "brrh ".

o The regular expression "br? " matches something that begins with a "b", is followed by
zero or one "r"s, and ends in a space. It would match "br ”, and "b ”, but would not
match "brrrr " or "brrh ".

o The regular expression "(..p)b" matches something ending with pb and beginning with
Whatever the two characters before the ﬁrst p encountered in the line were. It would ﬁnd
"repb" in "rep drepaqrepb". The regular expression "(..p)a" would find "repa qrepb” in
"rep drepa qrepb"

44 Writinq CMakeLists Files

0 The regular expression "d(..p)" matches something ending with p, beginning with d, and
having two characters in between that are the same as the two characters before the first
p encountered in the line. It would match "drepa qrepb" in "rep drepa qrepb".

4.5 Checking Versions of CMake

CMake is an evolving program and as new versions are released, new features or commands
may be introduced. As a result, there may be instances where you might want to use a
command that is in a current version of CMake but not in previous versions. There are a
couple of ways to handle this. One option is to use the if command to check whether a new
command exists. For example:

# test if the command exists

if (COMMAND someinewicommand)
# use the command
someinewicommand ( ARGS...)
endif (COMMAND some‘newvcommand)

The above approach should work in most cases, but if you need more information you can test
against the actual version of CMake that is being run by evaluating the CMAKEJ/ERSION
variables, as in the following example:

# look for newer versions of CMake

if ($ { CMAKEAVERSION} VERSIONiGREATER l . 6 . l)
# do something special here
endif 0

When writing your CMakeLists files you might decide that you do not want to support old
versions of CMake. To do this you can place the following command at the top of your
CMakeLists file:

cmake_minimum_required (VERSION 2.2)

This indicates that the person running CMake on your project must have at least CMake
version 2.2. If they are running an older version of CMake then an error message will be
displayed telling them that the project requires at least the speciﬁed version of CMake.

Using Modules 45

Finally, in some cases a new release of CMake might come out that no longer supports some
commands you were using (although we try to avoid this). In these cases you can use CMake
policies, as discussed in section 4.7.

4.6 Using Modules

Code reuse is a valuable technique in software development and CMake has been designed to
support it. Allowing CMakeLists ﬁles to make use of reusable modules enables the entire
CMake community to share reusable sections of code. For CMake these sections of code are
called modules and can be found in the Modules subdirectory of your CMake installation.
Modules are simply sections of CMake commands put into a ﬁle. They can then be included
into other CMakeLists ﬁles using the include command. For example, the following
commands will include the FindTCL module from CMake and then add the Tcl library to the
target FOO.

include (FindTCL)

target_linkilibraries (FOO ${TCL_LTBRARY})

A module’s location can be speciﬁed using the full path to the module ﬁle, or by letting
CMake ﬁnd the module by itself. CMake will look for modules in the directories speciﬁed by
CMAKEiMODULE#PATH and if it cannot ﬁnd it there, it will look in the Modules subdirectory
of CMake. This way projects can override modules that CMake provides, to customize them
for their needs. Modules can be broken into a few main categories:

Find Modules

These modules determine the location of software elements such as header ﬁles or
libraries.

System lntrospection Modules

These modules test the system for properties such as the size of a ﬂoat, support for
ANSI C++ streams, etc.

Utility Modules

These modules provide added functionality such as support for situations where one
CMake project depends on another and other convenience routines.

Now let us consider these three types of modules in more detail. CMake includes a large
number of Find modules. The purpose of a Find module is to locate software elements such as
header or library ﬁles. Ifthey cannot be found then they provide a cache entry so that the user
can set the required properties. Consider the following module that ﬁnds the PNG library.

46

¢ ¢ ¢ # ¢ # #

=tt==ﬁ:

=n=

#
[include ( FindZLIB.cmake )

Eif

Writinq CMakeLists Files

Find the native PNG includes and library

This module defines

PNG_INCLUDE_DIR, where to find png.h, etc.

PNG_LIBRARIES, the libraries to link against to use PNG.
PNG_DEFINITIONS - You should call

add_definitions (${PNGVDEFINITIONS}) before compiling code
that includes png library files.

PNG_FOUND, If false, do not try to use PNG.

also defined, but not for general use are
PNGiLIBRARY, where to find the PNG library.

None of the above will be defined unless zlib can be found.

PNG depends on Zlib

(ZLIB#FOUND)
findipath (PNG_PNG_INCLUDE7DIR png .h
/usr/local/include
/usr/include

)

find_library (PNG_LIBRARY png
/usr/lib

/usr/local/lib

)

if (PNGﬁLIBRARY)
if (PNG_PNG_INCLUDE_DIR)
# png.h includes zlib.h. Sigh.
set (PNG_INCLUDEﬂDIR
${PNGﬂPNGﬁINCLUDE_DIR} ${ZLIBRINCLUDE7DIR} )
set (PNGWLIBRARIES ${PNGﬁLIBRARY} ${ZLIB7LIBRARY})
set (PNG_FOUND "YES")

if (CYGWIN)
if (BUILDiSHAREDiLIBS)
# No need to define PNGﬁUSE_DLL here, because
# it's default for Cygwin.
else (BUILDiSHARED_LIBS)

Using Modules 47

set (PNG_DEFINITIONS -DPNG_STATIC)
endif (BUILD_SHARED_LIBS)
endif (CYGWIN)

endif ()
endif 0

‘endif ()

The top of the module clearly documents what the module will do and what variables it will
set. Next it includes another module, the FindZLIB module, that determines if the ZLib
library is installed. Next, if ZLib is found, the find_path command is used to locate the
PNG include ﬁles. The ﬁrst argument is the name of the variable to store the result in, the
second argument is the name of the header ﬁle to look for, the remaining arguments are paths
to search for the header ﬁle. If it is not found in the system path then the variable is set to
PNG_PNG_INCLUDE‘DIR—NOTFOUND, allowing the user to set it.

Note that the paths to search for the PNG library can include hard coded directories, registry
entries, and directories made up of other CMake variables. The next command ﬁnds the actual
PNG library using the f ind_l ibrary command. This command performs additional checks
to ﬁnd a proper library name, such as adding "lib" in front of the name and ".so" at the end of
the name on Linux systems.

After the ﬁnd calls, some CMake variables are set that developers using FindPNG can use in
their projects (such as the include paths, and library name). Finally PN G_FOUN D is set
correctly, which lets developers know that the PNG library was properly found.

This structure is fairly common to all Find modules in CMake. Usually they are fairly short,
but in some cases, such as FindOpenGL they can be a few pages long. They are normally
independent of other modules, but there is no restriction on the use of other modules.

System introspection modules provide information about the target platform or compiler.
Many of these modules have names preﬁxed with Test or Check, such as TestBigEndian
and CheckTypeSize. Many of the system introspection modules actually try to compile code
in order to determine the correct result. In these cases the source code is usually named the
same as the module, but with a .c or .cxx extension. System introspection modules are
covered in more detail in chapter 5.

CMake includes a few Utility modules to help make using CMake a little easier.
CMakeExportBuildSettings and CMakeImportBuildSettings provide tools to help
verify that two C++ projects are compiled with the same compiler and key ﬂags. The
CMakePrintSystemIn format ion module prints out a number ofkey CMake settings to aid
in debugging.

48 Writinq CMakeLists Files

Using CMake with SWIG

One example of how modules can be used is to look at wrapping your C/C++ code in another
language using SWIG. SWIG (Simpliﬁed Wrapper and Interface Generator) www.swig.org is
a tool that reads annotated C/C++ header ﬁles, and creates wrapper code (glue code) in order
to make the corresponding C/C++ libraries available to other programming languages such as
Tcl, Python, or Java. CMake supports SWIG with the f ind_package command. Although
SWIG can be used from CMake using custom commands, the SWIG package provides
several macros that make building SWIG projects with CMake simpler. To use the SWIG
macros, ﬁrst you must call the findﬁpackage command with the name SWIG. Then you
need to include the ﬁle referenced by the variable SWIGiU SE_FI LE. This will deﬁne several
macros and set up CMake to easily build SWIG based projects.

Two very useful macros are SWIGiADDiMODULE and SWIG_LINK‘LIBRARIES.
SWIGiADDJ/IODULE works much like the add_l ibrary command in CMake. The command
is invoked like this:

SWIG_ADDAMODULE (module_name language sourcel source2 m sourceN)

The ﬁrst argument is the name of the module to create. The next argument is the target
language SWIG is producing a wrapper for. The rest of the arguments consist of a list of
source ﬁles used to create the shared module. The big difference is that SWIG . i interface
ﬁles can be used directly as sources. The macro will create the correct custom commands to
run SWIG, and generate the C or C++ wrapper code from the SWIG interface ﬁles. The
sources can also be regular C or C++ ﬁles that need to be compiled in with the wrappers.

The SWIGALINK_LIBRARIES macro is used to link support libraries to the module. This
macro is used because depending on the language being wrapped by SWIG, the name of the
module may be different. The actual name of the module is stored in a variable called
SWIG_MODULE_${name}_REAL_NAME where $ {name} is the name passed into the
SWIG_ADD7MODULE macro. For example, SWIG_ADD_MODULE (foo tcl foo.i) would
create a variable called SWIG_MODULE_fOO_REAL_NAME which would contain the name of
the actual module created.

Now consider the following example that uses the SWIG example found in SWIG under
Examples/python/Class.

'# Find SWIG and include the use swig file
find_package (SWIG REQUIRED)
include (${SWIG_USE7FILE})

# Find python library and add include path for python headers
_findipackage (PythonLibs)
includeidirectories (${PYTHON_INCLUDE~PATH})

Usﬂq Modules 49

'# set the global swig flags to empty
set (CMAKEFSWIGﬁFLAGS "")

# let swig know that example.i is c++ and add the —includeall
_# flag to swig
Lset_source_files7properties (example.i PROPERTIES CPLUSPLUS ON)
set_source~filesfproperties (example.i
PROPERTIES SWIGiFLAGS "—includeall")

# Create the swig module called example
.# using the example.i source and example.cxx
# swig will be used to create wrapiexample.cxx from example.i
_SWIGiADDiMODULE (example python example.i example.cxx)
SWIGﬁLINK_LIBRARIES (example ${PYTHON7LIBRARIES})

This example ﬁrst uses f indﬁpackage to locate SWIG. Next it includes the
SWIG_USE_FILE deﬁning the SWIG CMake macros. Then it ﬁnds the Python libraries and
sets up CMake to build with the Python library. Notice that the SWIG input ﬁle examplei is
used like any other source ﬁle in CMake, and properties are set on the ﬁle telling SWIG that
the ﬁle is C++ and that the SWIG ﬂag —inc1udeall should be used when running SWIG on that
source ﬁle. The module is created by telling SWIG the name of the module, the target
language and the list of source ﬁles. Finally, the Python libraries are linked to the module.

Using CMake with Qt

Projects using the popular widget toolkit Qt from Nokia, qt.nokia.com, can be built with
CMake. CMake supports multiple versions of Qt, including versions 3 and 4. The ﬁrst step is
to tell CMake what version(s) of Qt to look for. Many Qt applications are designed to work
with Qt3 or Qt4, but not both. If your application is designed for Qt4 then you can use the
Finth4 module, for Qt3 you should use the Finth3 module. If your project can work with
either version of Qt then you can use the generic F inth module. All of the modules provide
helpful tools for building Qt projects. The following is a simple example of building a project
that uses Qt4.

find>package ( Qt4 )

if (QT/LFOUND)
include (${QT7USE_FILE})

# what are our ui files?

set (QTUI_SRCS thrapping.ui)
QT4_WRAP;UI (QTUIiHiSRCS $ {QTUI_SRCS })
QT4AWRAP_CPP (QT_MOC_SRCS TestMoc.h)

50 Writinq CMakeLists Files

 

addilibrary (myqtlib ${QTUIqH73RCS} ${QT7MOC*SRCS})
targetglink_libraries (myqtlib ${QTgLIBRARIES} )

addiexecutable (thrapping thrappingmain.cxx)
target_link_libraries (thrapping myqtlib)

' endif (QT4_FOUND)

Using CMake with FLTK

CMake also supports the The Fast Light Toolkit (FLTK) with special FLTK CMake
commands. The FLTK_WRAP_UI command is used to run the ﬂtk ﬂuid program on a .ﬂ ﬁle
and produce a C++ source ﬁle as part of the build. The following example shows how to use
FLTK with CMake.

find_package (FLTK)
. if (FLTKiFOUND)
set (FLTKiSRCS
fltkl.fl
)
FLTK_WRAP*UI (wraplibFLTK $ { FLTKiSRCSH
addilibrary (wraplibFLTK ${wraplibFLTK_UIgSRCS} )
endif (FLTK_FOUND)

4.7 Policies

For various reasons, sometimes a new feature or change is made to CMake that is not ﬁllly
backwards compatible with older versions of CMake. This can create problems when
someone tries to use an old CMakeLists ﬁle with a new version of CMake. To help both end
users and developers through such issues, we have introduced policies. Policies are a
mechanism in CMake to help improve backwards compatibility and track compatibility issues
between different versions of CMake.

Design Goals

There were four main design goals for the CMake policy mechanism:
1. Existing projects should build with versions of CMake newer than that used by the
project authors.

0 Users should not need to edit code to get the projects to build.
0 Warnings may be issued but the projects should build.

Policies 51

2. Correctness of new interfaces or bugs ﬁxes in old interfaces should not be inhibited by
compatibility requirements. Any reduction in correctness of the latest interface is not fair
on new projects.

3. Every change made to CMake that may require changes to a project’s CMakeLists ﬁles
should be documented.

0 Each change should also have a unique identiﬁer that can be referenced by warning
and error messages.

0 The new behavior is enabled only when the project has somehow indicated it is
supported.

4. We must be able to eventually remove code that implements compatibility with ancient
CMake versions.

0 Such removal is necessary to keep the code clean and to allow for internal
refactoring.

0 After such removal, attempts to build projects written for ancient versions must fail
with an informative message.

All policies in CMake are assigned a name of the form CMPNNNN where NNNN is an integer
value. Policies typically support both an old behavior that preserves compatibility with earlier
versions of CMake, and a new behavior that is considered correct and preferred for use by
new projects. Every policy has documentation detailing the motivation for the change, and the
old and new behaviors

Setting Policies

Projects may conﬁgure the setting of each policy to request old or new behavior. When
CMake encounters user code that may be affected by a particular policy it checks to see
whether the project has set the policy. If the policy has been set (to OLD or NEW) then
CMake follows the behavior speciﬁed. If the policy has not been set then the old behavior is
used, but a warning is issued telling the project author to set the policy.

There are a couple ways to set the behavior of a policy. The quickest way is to set all policies
to a version corresponding to the release version of CMake for which the project was written.
Setting the policy version requests the new behavior for all policies introduced in the
corresponding version of CMake or earlier. Policies introduced in later versions are marked as
not set in order to produce proper warning messages. The policy version is set using the
cmake_policy command's VERSION signature. For example, the code

cmake_policy (VERSION 2. 6)

will request the new behavior for all policies introduced in CMake 2.6 or earlier. The
cmake_minimum_required command will also set the policy version, which is convenient
for use at the top of projects. A project should typically begin with the lines

52 Writinq CMakeLists Files

jcmake_minimum_required (VERSION 2.6)
lproject (MyProject)
.# ...code using CMake 2.6 policies

Of course one should replace "2.6" with whatever version of CMake you are currently writing
to. You can also set each policy individually if you wish. This is sometimes helpful for project
authors who want to incrementally convert their projects to use the new behavior, or silence
warnings about dependence on old behavior. The cmakeﬁpolicy command's SET option
may be used to explicitly request old or new behavior for a particular policy.

For example, CMake 2.6 introduced policy CMPO 002, which requires all logical target names
to be globally unique (duplicate target names previously worked in some cases by accident
but were not diagnosed). Projects using duplicate target names and working accidentally will
receive warnings referencing the policy. The warnings may be silenced by the code

icmake_policy (SET CMPOOOZ OLD)
which explicitly tells CMake to use the old behavior for the policy (silently accept duplicate
target names). Another option is to use the code

,cmake’policy (SET CMPOOOZ NEW)

to explicitly tell CMake to use new behavior and produce an error when a duplicate target is
created. Once this is added to the project it will not build until the author removes any
duplicate target names.

When a new version of CMake is released that introduces new policies it will still build old
projects, because by default they do not request NEW behavior for any of the new policies.
When starting a new project one should always specify the most recent release of CMake to
be supported as the policy version level. This will make sure that the project is written to
work using policies from that version of CMake and not using any old behavior. If no policy
version is set CMake will warn and assume a policy version of 2.4. This allows existing
projects that do not specify cmake_minimum_required to build as they would have with
CMake 2.4.

The Policy Stack

Policy settings are scoped using a stack. A new level of the stack is pushed when entering a
new subdirectory of the project (with addvsubdirectory) and popped when leaving it.
Therefore setting a policy in one directory of a project will not affect parent or sibling
directories, but will affect subdirectories.

Policies 53

This is useﬁll when a project contains subprojects maintained separately but built inside the
tree. The top-level CMakeLists ﬁle in a project may write

5 cmake_policy (VERSION 2.6)

:project (MyProject)

iadd_subdirectory (OtherProject)

i # ... code requiring new behavior as of CMake 2.6 ...

while the OtherProject/CMakeLists . txt ﬁle contains

1cmake_policy (VERSION 2.4)
gproject (OtherPrOject)
§# ... code that builds with CMake 2.4

This allows a project to be updated to CMake 2.6 while subprojects, modules, and included
ﬁles continue to build with CMake 2.4 until their maintainers update them.

User code may use the cmake_policy command to push and pop its own stack levels as long
as every push is paired with a pop. This is useful to temporarily request different behavior for
a small section of code. For example, policy CMPO OO 3 removes extra link directories that used
to be included when new behavior is used. While incrementally updating a project it may be
difficult to build a particular target with the new behavior but all other targets are okay. The
code

3cmakeApolicy (PUSH)

‘cmakeipolicy (SET CMPOOO3 OLD) # use old—style link for now
} add_executable (myexe ...)

‘cmake_policy (POP)

will silence the warning and use the old behavior for that target. You can get a list of policies
and help on speciﬁc policies by running cmake from the command line as follows

lcmake —-help-command cmake_policy
cmake -vhelp-policies
‘cmake -—help-policy CMPOOO3

Updating a Project For a New Version of CMake

When a CMake release introduces new policies it may generate warnings for some existing
projects. These warnings indicate that changes to the project may need to be made to deal
correctly with the new policies. While old releases of the project can continue to build with

54 Writinq CMakeLists Files

the warnings the project development tree should be updated to take the new policies into
account. There are two approaches to updating a tree: one-shot and incremental. Which one is
easier depends on the size of the project and what new policies produce warnings.

The One-Shot Approach

The simplest approach to updating a project for a new version of CMake is simply to change
,the policy version set at the top of the project, try building with the new CMake version, and
ﬁx problems. For example, to update a project to build with CMake 2.8 one might write

cmakeiminimumirequired (VERSION 2. 8)

at the beginning of the top-level CMakeLists ﬁle. This tells CMake to use the new behavior
for every policy introduced in CMake 2.8 and below. When building this project with CMake
2.8 no warnings will be produced about policies because it knows of no policies introduced in
later versions. However, if the project was depending on the old behavior of a policy it may
not build since CMake now uses the new behavior without warning. It is up to the project
author who added the policy version line to ﬁx these issues.

The Incremental Approach

Another approach to updating a project for a new version of CMake is to deal with each
waming one—by-one. One advantage of this approach is that the project will continue to build
throughout the process, so the changes can be made incrementally.

When CMake encounters a situation where it needs to know whether to use the old or new
behavior for a policy, it checks whether the project has set the policy. If the policy is set
CMake silently uses the corresponding behavior. If the policy is not set, CMake uses the old
behavior but warns that the policy is not set.

In many cases the warning message will point at the exact line of code in the CMakeLists ﬁles
that caused the warning. In some cases the situation cannot be diagnosed until CMake is
generating the native build system rules for the project, so the warning will not include
explicit context information. In these cases CMake will try to provide some information about
where code may need to be changed. The documentation for these "generation-time" policies
should indicate the point in the project code at which the policy should be set to take effect.

In order to incrementally update a project one warning should be addressed at a time. Several
cases may occur as described below.

Silence a Warning When the Code is Correct

Many policy warnings may be produced simply because the project has not set the policy
even though the project may work correctly with the new behavior (there is no way for
CMake to know the difference). For a warning about some policy CMP<NNNN> one may check
whether this is the case by adding

Policies 55

cmake_policy (SET CMP<NNNN> NEW)

to the top of the project and trying to build it. If the project builds correctly with the new
behavior one may move on to the next policy warning. If the project does not build correctly
one of the other cases may apply.

Silence a Warning Without Updating the Code
One may suppress all instances of a warning CMP<NNNN> by adding

cmake_policy (SET CMP<NNNN> OLD)

at the top of a project. However, we encourage project authors to update their code to work
with the new behavior for all policies. This is especially important because versions of CMake
in the (distant) future may remove support for the old behavior and produce an error for
projects requesting it (which tells the user to get an older CMake to build the project).

Silence a Warning by Updating Code

When a project does not work correctly with the NEW behavior for a policy its code needs to
be updated. In order to deal with a warning for some policy CMP<NNNN> one may add

i cmake_policy (SET CMP<NNNN> NEW)

at the top of the project and then ﬁx the code to work with the NEW behavior.

If many instances of the warning occur ﬁxing all of them simultaneously may be too difﬁcult.
Instead a developer may ﬁx one at a time. This may be done using the PUSH/POP signatures
of the cmake_policy command:

icmake_policy (PUSH)

f cmakeﬁpolicy (SET CMP<NNNN> NEW)

‘ # ... code updated for new policy behavior ...
cmake*policy (POP)

This will request the new behavior for a small region of code that has been ﬁxed. Other
instances of the policy warning may still appear and must be ﬁxed separately.

Updating the Project Policy Version

Aﬁer addressing all policy warnings and getting the project to build cleanly with the new
CMake version one step remains. The policy version set at the top of the project should now
be updated to match the new CMake version, just as in the one-shot approach above. For

56 Writinq CMakeLists Files

example, after updating a project to build cleanly with CMake 2.8 one may update the top of
the project with the line

cmake_minimum_required(VERSION 2.8)

This will set all policies introduced in CMake 2.8 or below to use the new behavior. Then one
may sweep through the rest of the code and remove all the calls to the cmakeipolicy
command used to request the new behavior incrementally. The end result should look the
same as the one-shot approach above but could be attained step-by—step.

Supporting Multiple CMake Versions

Some projects might want to support a few releases of CMake simultaneously. The goal is to
build with an older version but also work with newer versions without warnings. In order to
support both CMake 2.4 and 2.6, one may write code like

cmakeﬁminimum_required (VERSION 2.4)
if (COMMAND cmake_policy)

# policy settings

cmakeipolicy (SET CMP0003 NEW)
endif (COMMAND cmake_policy)

This will set the policies when building with CMake 2.6 and just ignore them for CMake 2.4.
In order to support both CMake 2.6 and some policies of CMake 2.8, one may write code like

cmake_minimum_required (VERSION 2.6)

if (POLICY CMP1234)
# policies not known to CMake 2.6 ...
cmake!policy (SET CMP1234 NEW)

endif (POLICY CMP1234)

This will set the policies when building with CMake 2.8 and just ignore them for CMake 2.6.
If it is known that the project builds with both CMake 2.6 and CMake 2.8's new policies one
may write

cmakekminimum_required (VERSION 2.6)

if (NOT ${CMAKE7VERSION} VERSIONﬁLESS 2.8)
cmakeipolicy (VERSION 2.8)

endif 0

Linking Libraries 57

 

4.8 Linking Libraries

In CMake 2.6 and later a new approach to generating link lines for targets has been
implemented. Consider these libraries:

~/path/to/libfoo.a
,/path/to/libfoo.so

Previously if someone wrote
{target;linkflibrariés (myexe /path/to/libfoofa)
CMake would generate this code to link it:
-L/path/tor—Wl,sttat c elfoo -Wl,—denamic

This worked most of the time, but some platforms (such as Mac OS X) do not support the —
Bstatic or equivalent ﬂag. This made it impossible to link to the static version of a library
without creating a symlink in another directory and using that one instead. Now CMake will
generate this code:

. /path/to/libfoo.a

This guarantees that the correct library is chosen. However there are some caveats to keep in
mind. In the past a project could write this (incorrect) code, and it would work by accident:

add_executable (myexe myexe.c)
target_link_libraries (myexe /path/to/libA.so B)

where "B" is meant to link "/path/to/libB.so". This code is incorrect because it asks
CMake to link to B but does not provide the proper linker search path for it. It used to work by
accident because the —L/path/ to would get added as part of the implementation of linking
to A. The correct code would be either

Llinkgdirectories (/path/to)
fadd_executable (myexe myexe.c)
target_link‘libraries (myexe /path/to/libA.so B)

58 Wri'tinq CMakeLists Files

or even better
laddﬂexecutable (myexe myexe.c)
target_link_libraries (myexe /path/to/libA.so /path/to/libB.so)

Linking to System Libraries

System libraries on UNIX—like systems are typically provided in /usr/ lib or / lib. These
directories are considered implicit linker search paths because linkers automatically search
these locations, even without a ﬂag like -L/ us r/ lib. Consider the code

find_library (M_LIB m)
targetglink_libraries (myexe ${M_LIB})

Typically the find_library command would ﬁnd the math library /usr/lib/libm.so,
but some platforms provide multiple versions of libraries correesponding to different
architectures. For example, on an IRIX machine one might ﬁnd the libraries

L/usr/lib/libm.so (ELF O32)

/usr/lib32/libm.so (ELF n32)
_/usr/lib64/libm.so (ELF 64)

On a Solaris machine one might ﬁnd

/usr/lib/libm.so (sparcv8 architecture)
/usr/lib/sparcv9/libm.so (sparcv9 architecture)

Unfortunately, findﬁlibrary may not know about all of the architecture—speciﬁc system
search paths used by the linker. In fact, when it ﬁnds /usr/ lib/ libm. so, it may be ﬁnding
a library with the incorrect architecture. If the link computation were to produce the line

/usr/lib/libm.so

the linker might complain if /usr/lib/libm. so does not match the architecture it wants.
One solution to this problem is for the link computation to recognize that the library is in a
system directory and ask the linker to search for the library. It could produce the link line

—lm ...

Shared Libraries and Loadable Modules 59

 

and the linker would search through its architecture-speciﬁc implicit link directories to ﬁnd
the correct library. Unfortunately, this solution suffers from the original problem of
distinguishing between static and shared versions. In order to ask the linker to ﬁnd a static
system library with the correct architecture it must produce the link line

. —Wl,-Bstatic —lm ... —Wl,—Bshared ...

Since not all platforms support such ﬂags CMake compromises. Libraries that are not in
implicit system locations are linked by passing the full library path to the linker. Libraries that
are in implicit system locations (such as / us r/ lib) are linked by passing the —1 option if a
ﬂag like —Bstatic is available, and by passing the full library path to the linker otherwise.

Specifying Optimized or Debug Libraries with a Target

On Windows platforms it is often required to link debug libraries with debug libraries, and
optimized libraries with optimized libraries. CMake helps satisfy this requirement with the
target_linkilibraries command, which accepts an optional ﬂag that is debug or
optimized. So, if a library is preceded with either debug or optimized, then that library will
only be linked in with the like conﬁguration type. For example:

1 add_executable (foo foo.c)
‘target‘link_libraries (foo debug libdebug optimized libopt)

In this case foo will be linked against libdebug if a debug build was selected, or against libopt
if an optimized build was selected.

4.9 Shared Libraries and Loadable Modules

Shared libraries and loadable modules are very powerﬁil tools for software developers. They
can be used to create extension modules or plugins for off-the—shelf software, and can be used
to decrease the compile/link/run cycles for C and C++ programs. However, despite years of
use, the cross platform creation of shared libraries and modules remains a black art
understood by only a few developers. CMake has the ability to aid developers in the creation
of shared libraries and modules. CMake lmows the correct tools and ﬂags to use in order to
produce the shared libraries for most modern operating systems that support them.
Unfortunately, CMake cannot do all the work, and developers must sometimes alter source
code and understand the basic concepts and common pitfalls associated with shared libraries
before they can be used effectively. This section will describe many of the issues required to
take advantage of shared libraries and loadable modules.

A shared library should be thought of more like an executable than a static library, and on
most systems actually requires executable permissions to be set on the shared library ﬁle. This

60 Writing CMakeLists Files

means that shared libraries can link to other shared libraries when they are created in the same
way as an executable. Unlike a static library where the atomic unit is the object ﬁle, for shared
libraries, the entire library is the atomic unit. This can cause some unexpected linker errors
when converting from static to shared libraries. If an object ﬁle is part of a static library, but
the executable linking to the library does not use any of the symbols in that object ﬁle, then
the ﬁle is simply excluded from the ﬁnal linked executable. With shared libraries, all the
object ﬁles that make up the library and all of the dependencies that they require come as one
unit. For example, suppose you had a library with an object ﬁle deﬁning the ﬁinction
Di splayOnXWindow( ) which required the X11 library. If you linked an executable to that
library, but did not call the Di splayOnXWindow () function, the static library version would
not require X1 1, but the shared library version would require the X11 library. This is because
a shared library has to be taken as one unit, and a static library is only an archive of object
ﬁles from which linkers can choose which objects are needed. This means that static linked
executables can be smaller, as they only contain the object code actually used.

Another difference between shared and static libraries is library order. With static libraries the
order on the link line can make a difference. This is because most linkers only use the
symbols that are needed in a single pass over all the given libraries. So, the library order
should go from the library that uses the most other libraries to the library that uses no other
libraries. CMake will preserve and remember the order of libraries and library dependencies
of a project. This means that each library in a project should use the
target‘linkvlibraries command to specify all of the libraries that it directly depends
on. The libraries will be linked with each other for shared builds, but not static builds.
However, the link information is used in static builds when executables are linked. An
executable that only links library libA will get libA plus libB and libC as long as libA’s
dependency on libB and libC was properly speciﬁed using targetAliniﬁlibraries
(libA libB libC).

At this point, one might wonder why shared libraries would be preferred over static libraries.
There are several reasons. First, shared libraries can decrease the compile/link/run cycle time.
This is because the linker does not have to do as much work when linking to shared libraries
because there are fewer decisions to be made about which object ﬁles to keep. Also, often
times, the executable does not even need to be re-linked aﬁer the shared library is rebuilt. So,
developers can work on a library compiling and linking only the small part of the program
that is currently being developed, and then re—run the executable after each build of the shared
library. Also, if a library is used by many different executables on a system, then there only
needs to be one copy of the library on disk, and often in memory too.

In addition to the concept of a software library, shared libraries can also be used on many
systems as run time loadable modules. This means that a program can at run time, load and
execute object code that was not part of the original software. This allows developers to create
software that is both open and closed. (For more information see Object Oriented Soﬁware
Construction by Bertrand Meyer.) Closed software is soﬁware that cannot be modiﬁed. It has
been through a testing cycle and can be certiﬁed to perform speciﬁc tasks with regression

Shared Libraries and Loadable Modules 61

tests. However, a seemingly opposite goal is sought after by developers of object oriented
software. This is the concept of Open software that can be extended by future developers.
This can be done via inheritance and polymorphism with object systems. Shared libraries that
can be loaded at run time, allow for these seemingly opposing goals to be achieved in the
same software package. Many common applications support the idea of plugins. The most
common of these applications is the web browser. Internet Explorer uses plugins to support
video over the web and 3D visualization. In addition to plugins, loadable factories can be used
to replace C++ objects at run time, as is done in VTK.

Once it is decided that shared libraries or loadable modules are the right choice for a
particular project, there are a few issues that developers need to be aware of. The ﬁrst
question that must be answered is which symbols are exported by the shared library? This
may sound like a simple question, but the answer is different from platform to platform. On
many, but not all UNIX systems, the default behavior is to export all the symbols much like a
static library. However, on Windows systems, developers must explicitly tell the linker and
compiler which symbols are to be exported and imported from shared libraries. This is often a
big problem for UNIX developers moving to Windows. There are two ways to tell the
compiler/linker which symbols to export/import on Windows. The most common approach is
to decorate the code with a MicrosoftTM C/C++ language extension. An alternative is to create
an extra ﬁle called a .def ﬁle. This ﬁle is a simple ASCII ﬁle containing the names of all the
symbols to be exported from a library.

The MicrosoftTM extension uses the ﬁdeclspec directive. If a symbol has ~declspec (
dllexport ) hlﬁontofﬁ,ﬁ\NﬂlbeeXp0ﬁed,andifithas_~declspec( dllimport ) R
will be imported. Since the same ﬁle may be shared during the creation and use of a library, it
must be both exported and imported in the same source ﬁle. This can only be done with the
preprocessor. The developer can create a macro called LIBRARY_EXPORT that is deﬁned to
dl lexport when building the library and dllimport when using the library. CMake helps
this process by automatically deﬁning $ { LIBNAME LEXPORTS when building a DLL
(dynamic link library, aka. a shared library) on Windows.

The following code snippet is from the VTK library vtkCommon, and is included by all ﬁles
in the vtkCommon library:

\ #if defined(WIN32)

#if defined(vtkCommon_EXPORTS)
#define VTKWCOMMON_EXPORT _ideclspec( dllexport )
#else
#define VTK_COMMON_EXPORT _Vdeclspec( dllimport )
‘ #endif '
#else
#define VTK_COMMON#EXPORT
#endif

62 Writinq CMakeLists Files

The example checks for Windows and checks the vtkCommon_EXPORTs macro provided by
CMake. So, on UNIX VTK_COMMON_EXPORT is deﬁned to nothing, and on Windows during
the building of vtkCommon.dll it is deﬁned as wdeclspec (dllexport) , and when the ﬁle
is being used by another ﬁle, it is deﬁned to _declspec (dllimport).

The second approach requires a .def ﬁle to specify the symbols to be exported. This ﬁle could
be created by hand, but for a large and changing C++ library that could be time consuming
and error prone. CMake’s custom commands can be used to run a pre-link program that will
create a .def ﬁle from the compiled object ﬁles automatically. In the following example, a
Perl script called makedef .pl is used, the script runs the DUMPBIN program on the .obj ﬁles
and extracts all of the exportable symbols and writes a .def ﬁle with the correct exports for all
the symbols in the library mylib.

————CMakeLists.txt —————

cmake_minimumgrequired (VERSION 2.6)
project (myexe)

_set (SOURCES mylib.cxx mylib2.cxx)

_# create a list of all the object files
string (REGEX REPLACE "\\.CXX" ".obj" OBJECTS "${SOURCES}“)

# create a shared library with the .def file
addﬁlibrary (mylib SHARED ${SOURCES}
${CMAKEiCURRENTWBINARY_DIR}/mylib.def
)
L# set the .def file as generated
set_sourcegfiles~properties (
' $ { CMAKE‘CURRENTgBINARYgDIR} /myl ib. de f
PROPERTIES GENERATED l
)

§# create an executable
add_executable (myexe myexe.cxx)

# link the executable to the dll
target_link_libraries(myexe mylib)

‘#convert to windows slashes

Iset (OUTDIR
$ { CMAKE_CURRENT_BINARY_DIR} / $ { CMAKEWCFG_INTDIR}
)

Shared Libraries and Loadable Modules 63

string (REGEX REPLACE "/" "\\\\" OUTDIR ${OUTDIR})

# create a custom pre link command that runs
# a perl script to create a .def file using dumpbin
add_custom_command (
TARGET myl ib PREiL INK
COMMAND perl
ARGS S {CMAKE#CURRENT750URCE7DIR} /makedef . pl
${CMAKE_CURRENT_BINARYADIR}\\mylib.def mylib
${OUTDIR} ${OBJECTS}
COMMENT "Create .def file"
)

:———myexe.cxx————
#include <iostream>
#include "mylib.h"
int main()

{

‘ std::cout << myTen() << "\n";

std::cout << myEight() << "\n";

r———mylib.cxx--
int myTen()
{

return 10;

- ——mylib2.cxx———
int myEight()
} {

return 8;

64 WritingCMakeLists Files

There is a signiﬁcant difference between Windows and most UNIX systems with respect to
the requirements of symbols. DLLs on Windows are required to be fully resolved, this means
that they must link every symbol at creation. UNIX systems allow shared libraries to get
symbols from the executable or other shared libraries at run time. On UNIX systems that
support this feature, CMake will compile with the ﬂags that allow executable symbols to be
used by shared libraries. This small difference can cause large problems. A common, but hard
to track down bug with DLLs happens with C++ template classes and static members. Two
DLLs can end up with separate copies of what is supposed to be a single global static member
of a class. There are also problems with the approach taken on most UNIX systems. The start
up time for large applications with many symbols can be long since much of the linking is
deferred to run time.

Another common pitfall occurs with C++ global objects. These objects require that
constructors must be called before they can be used. The main that links or loads C++ shared
libraries MUST be linked with the C++ compiler, or globals like cout may not be initialized
before they are used, causing strange crashes at start up time.

Since executables that link to shared libraries must be able to ﬁnd the libraries at run time,
special environment variables and linker ﬂags must be used. There are tools that can be used
to show which libraries an executable is actually using. On many UNIX systems there is a
tool called ldd (otool —L on Mac OS X) that shows which libraries are used by an
executable. On Windows, a program called depends can be used to ﬁnd the same type of
information. On many UNIX systems there are also environment variables like
LD_LIBRARY_PATH that tell the program where to ﬁnd the libraries at run time. Where
supported CMake will add run time library path information into the linked executables, so
that LDﬁLIBRARY_PATH is not required. This feature can be turned off by setting the cache
entry CMAKE_SKIP_RPATH to false. This may be desirable for installed software that should
not be looking in the build tree for shared libraries. On Windows there is only one PATH
environment variable that is used for both DLLs and ﬁnding executables.

4.10 Shared Library Versioning

When an executable is linked to a shared library, it is important that the copy of the shared
library loaded at runtime matches that expected by the executable. On some UNIX systems, a
shared library has an associated "soname" intended to solve this problem. When an executable
links against the library, its soname is copied into the executable. At runtime, the dynamic
linker uses this name from the executable to search for the library.

Consider a hypothetical shared library "foo" providing a few C functions that implement some
functionality. The interface to foo is called an Application Programming Interface (API). If
the implementation of these C functions changes in a new version of foo, but the API remains
the same, then executables linked against foo will still run correctly. When the API changes,

Shared Library Versioninq 65

old executables will no longer run with a new copy of foo, so a new API version number must
be associated with foo.

This can be implemented by creating the original version of foo with a soname and ﬁle name
such as libfoo.so.l. A symbolic link such as libfoo.so -> libfoo.so.l will allow standard
linkers to work with the library and create executables. The new version of foo can be called
libfoo.so.2 and the symbolic link updated so that new executables use the new library. When
an old executable runs, the dynamic linker will look for libfoo.so.l, ﬁnd the old copy of the
library, and run correctly. When a new executable runs, the dynamic linker will look for
libfoo.so.2 and correctly load the new version.

This scheme can be expanded to handle the case of changes to foo that do not modify the API.
We introduce a second set of version numbers that is totally independent of the ﬁrst. This new
set corresponds to the software version providing foo. For example, some larger project may
have introduced the existence of library foo starting in version 3.4. In this case, the ﬁle name
for foo might be libfoo.so.3.4, but the soname would still be libfoo.so.l because the API for
foo is still on its ﬁrst version. A symbolic link from libfoo.so.l -> libfoo.so.3.4 will allow
executables linked against the library to run. When a bug is ﬁxed in the software without
changing the API to foo, then the new library ﬁle name might be libfoo.so.3.5, and the
symbolic link can be updated to allow existing executables to run.

CMake supports this soname-based version number encoding on platforms supporting soname
natively. A target property for the shared library named "VERSION" speciﬁes the version
number used to create the ﬁle name for the library. This version should correspond to that of
the software package providing foo. On Windows the VERSION property is used to set the
binary image number, using majorminor format. Another target property named
"SOVERSION" speciﬁes the version number used to create the soname for the library. This
version should correspond to the API version number for foo. These target properties are
ignored on platforms where CMake does not support this scheme.

The following CMake code conﬁgures the version numbers of the shared library foo:

set_target_properties (foo PROPERTIES VERSION 1.2 SOVERSION 4)

This results in the following library and symbolic links:

libfoo.so.l.2
alibfoo.so.4 —> libfoo.so.l.2
libfoo.so —> libfoo.so.4

If only one of the two properties is speciﬁed, the other defaults to its value automatically. For
example, the code

66 Writinq CMakeLists Files

setﬂtarget_properties (foo PROPERTIES VERSION 1.2)

results in the following shared library and symbolic link:

libfoo.so.l.2
ilibfoo.so ~> libfoo.so.l.2

CMake makes no attempt to enforce sensible version numbers. It is up to the programmer to
utilize this feature in a productive manner.

4.11 Installing Files

Software is typically installed into a directory separate from the source and build trees. This
allows it to be distributed in a clean form and isolates users from the details of the build
process. CMake provides the install command to specify how a project is to be installed.
This command is invoked by a project in the CMakeLists ﬁle and tells CMake how to
generate installation scripts. The scripts are executed at install time to perform the actual
installation of ﬁles. For Makeﬁle generators (UNIX, NMake, Borland, MinGW, etc), the user
simply runs "make install" (or “nmake install”) and the make tool will invoke
CMake's installation module. With GUI based systems (Visual Studio, Xcode, etc.) the user
simply builds the target called INSTALL.

Each call to the install command deﬁnes some installation rules. Within one CMakeLists
ﬁle (source directory) these rules will be evaluated in the order in which the corresponding
commands are invoked. The order across multiple directories is not speciﬁed.

The install command has several signatures designed for common installation use cases. A
particular invocation of the command speciﬁes the signature as the ﬁrst argument. The
signatures are TARGETS, FILES, PROGRAMS, DIRECTORY, SCRIPT, and CODE.

install (TARGETS ...)

Install the binary ﬁles corresponding to targets built inside the project.

install (FILES ...)

General-purpose ﬁle installation. It is typically used for installation of header ﬁles,
documentation, and data ﬁles required by your soﬁware.

install (PROGRAMS ...)

Installs executable ﬁles not built by the project, such as shell scripts. It is identical to
install (FILES) except that the default permissions of the installed ﬁle include
the executable bit.

Installing Files 67

install (DIRECTORY ...)

Install an entire directory tree. This may be used for installing directories with
resources such as icons and images.

install (SCRIPT ...)

Specify a user-provided CMake script ﬁle to be executed during installation.
Typically this is used to deﬁne pre-install or post-install actions for other rules.

install (CODE . . .)

Specify user-provided CMake code to be executed during the installation. This is
similar to install (SCRIPT) but the code is provided inline in the call as a string.

The TARGETS, FILES, PROGRAMS, DIRECTORY signatures are all meant to create install rules
for ﬁles. The targets, ﬁles, or directories to be installed are listed immediately after the
signature name argument. Additional details can be speciﬁed using keyword arguments
followed by corresponding values. Keyword arguments provided by most of the signatures are
as follows.

DESTINATION

Speciﬁes the location in which the installation rule will place ﬁles. This argument
must be followed by a directory path indicating the location. If the directory is
speciﬁed as a full path it will be evaluated at install time as an absolute path. If the
directory is speciﬁed as a relative path it will be evaluated at install time relative to
the installation preﬁx. The preﬁx may be set by the user through the cache variable
CMAKE_INSTALL_PREEIX. A platform-speciﬁc default is provided by CMake:
“/usr/local” on UNIX and “<SystemDrive>/ Program Files/<ProjectName>”
on Windows, where SystemDrive is something like “C:” and ProjectName is the
name given to the top-most PROJECT command.

PERMISSIONS

Speciﬁes ﬁle permissions to be set on the installed ﬁles. This option is needed only
to override the default permissions selected by a particular INSTALL command
signature. Valid permissions are OWNER_READ, OWNER_WRITE, OWNER_EXECUTE,
GROUP_READ, GROUP_WRITE, GROUP_EXECUTE, WORLD_READ, WORLD_WRITE,
WORLD_EXECUTE, SETUID, and SETGID. Some platforms do not support all of these
permissions, on such platforms those permission names are ignored.

CONFIGURATIONS

Speciﬁes a list of build conﬁgurations for which an installation rule applies (Debug,
Release, etc). For Makeﬁle generators the build conﬁguration is speciﬁed by the
CMAKEVBUILDiTYPE cache variable. For Visual Studio and Xcode generators the
conﬁguration is selected when the INSTALL target is built. An installation rule will

68 Writing CMakeLists Files

be evaluated only if the current install conﬁguration matches an entry in the list
provided to this argument. Conﬁguration name comparison is case-insensitive.

COMPONENT

Speciﬁes the installation component for which the installation rule applies. Some
projects divide their installations into multiple components for separate packaging.
For example, a project may deﬁne a “Runtime” component that contains the ﬁles
needed to run a tool, a “Development” component containing the ﬁles needed to
build extensions to the tool, and a “Documentation” component containing the
manual pages and other help ﬁles. The project may then package each component
separately for distribution by installing only one component at a time. By default all
components are installed. Component-speciﬁc installation is an advanced feature
intended for use by package maintainers. It requires manual invocation of the
installation scripts with an argument deﬁning the COMPONENT variable to name the
desired component. Note that component names are not deﬁned by CMake. Each
project may deﬁne its own set of components.

OPTIONAL

Speciﬁes that it is not an error if the input ﬁle to be installed does not exist. If the
input ﬁle exists it will be installed as requested. If it does not exist it will be silently
not installed.

Projects typically install some of the library and executable ﬁles created during their build
process. The install command provides the TARGETS signature for this purpose:

~install (TARGETS targets...
[ [ARCHIVE l LIBRARY | RUNTIME [ FRAMEWORK [ BUNDLE |

PRIVATEAHEADER | PUBLICAHEADER l RESOURCE]

[DESTINATION <dir>]

[PERMISSIONS permissions...]
[CONFIGURATIONS [DebuglReleasel...l]
[COMPONENT <component>]

[OPTIONAL]

[EXPORT <export name>l
[NAMELINK/ONLYlNAMELINK/SKIP]
l l. . . l )

The TARGETS keyword is immediately followed by a list of the targets created using
add_executable or add_library to be installed. One or more ﬁles corresponding to each
target will be installed.

Files installed with this signature may be divided into three categories: ARCHIVE, LIBRARY,
and RUNTTME. These categories are designed to group target ﬁles by typical installation

Installing Files 69

destination. The corresponding keyword arguments are optional, but if present specify that
other arguments following them apply only to target ﬁles of that type. Target ﬁles are
categorized as follows:

executables - RUNTIME

Created by addAexecutable (.exe on Windows, no extension on UNIX)

loadable modules - LIBRARY
Created by addilibrary with the MODULE option (.dll on Windows, .so on UNIX)

shared libraries - LIBRARY

Created by add_library with the SHARED option on UNIX-like platforms (.so on
most UNIX, .dylib on Mac)

dynamic-link libraries - RUNTIME:
Created by add_library with the SHARED option on Windows platforms (.dll)

import libraries - ARCHIVE

Linkable ﬁle created by a dynamic-link library that exports symbols (.lib on most
Windows, .dll.a on Cygwin and MinGW).

static libraries - ARCHIVE

Created by add_library with the STATIC option (.lib on Windows, .a on UNIX,
Cygwin, and MinGW)

Consider a project that deﬁnes an executable myExeCutable that links to a shared library
mySharedLib. It also provides a static library myStaticLib and a plugin module to the
executable called myPlugin that also links to the shared library. The executable, static
library, and plugin ﬁle may be installed individually using the commands

« install (TARGETS myExecutable DESTINATION bin)
install (TARGETS myStaticLib DESTINATION lib/myproject)
install (TARGETS myPlugin DESTINATION lib)

The executable will not be able to run from the installed location until the shared library to
which it links is also installed. Installation of the library requires a bit more care in order to
support all platforms. It must be installed to a location searched by the dynamic linker on each
platform. On UNIX-like platforms the library is typically installed to lib,while on Windows
it should be placed next to the executable in bin. An additional challenge is that the import
library associated with the shared library on Windows should be treated like the static library
and installed to lib/myproject. In other words we have three different kinds of ﬁles
created with a single target name that must be installed to three different destinations!

70 Writing CMakeLlsts Files

Fortunately this problem can be solved using the category keyword arguments. The shared
library may be installed using the command

install (TARGETS mySharedLib
RUNTIME DESTINATION bin
LIBRARY DESTINATION lib
ARCHIVE DESTINATION lib/myproject)

This tells CMake that the RUNTIME ﬁle (.dll) should be installed to bin, the LIBRARY ﬁle
(.so) should be installed to lib, and the ARCHIVE (.lib) ﬁle should be installed to
lib/myproj ect. On UNIX the LIBRARY ﬁle will be installed and on Windows the RUNTIME
and ARCHIVE ﬁles will be installed.

If the above sample project is to be packaged into separate runtime and development
components we must assign the appropriate component to each target ﬁle installed. The
executable, shared library, and plugin are required in order to run the application, so they
belong in a Runtime component. Meanwhile the import library (corresponding to the shared
library on Windows) and the static library are only required to develop extensions to the
application, and therefore belong in a Development component.

Component assignments may be speciﬁed by adding the COMPONENT argument to each of the
commands above. We may also combine all of the installation rules into a single command
invocation. This single command is equivalent to all of the above commands with
components added. The ﬁles generated by each target are installed using the rule for their
category.

install (TARGETS myExecutable mySharedLib myStaticLib myPlugin
RUNTIME DESTINATION bin COMPONENT Runtime
LIBRARY DESTINATION lib COMPONENT Runtime
ARCHIVE DESTINATION lib/myproject COMPONENT Development)

Either NAMELINK_ONLY or NAMELINKﬂSKIP may be speciﬁed as a LIBRARY option. On some
platforms a versioned shared library has a symbolic link such as

lib<name>.so -> lib<name>.so.l

Where lib<name>.so.l is the soname of the library and lib<name>.so is a "namelink"
that helps linkers to ﬁnd the library when given —l<name>. The NAMELINI/LONLY option
causes installation of only the namelink when a library target is installed The
NAMELINK_SKIP option causes installation of library ﬁles other than the namelink when a
library target is installed. When neither option is given both portions are installed. On

lnstallinﬁiles 71

 

platforms where versioned shared libraries do not have namelinks, or when a library is not
versioned, the NAMELINK_SKIP option installs the library and the NAMELINKiONLY option
installs nothing. See the VERSION and SOVERS ION target properties for details on creating
versioned shared libraries.

Projects may install ﬁles other than those that are created with add_executable or
add_library, such as header ﬁles or documentation. General-purpose installation of ﬁles is
speciﬁed using the FILES signature:

[install (FILES files... DESTINATION <dir>
[PERMISSIONS permissions...]
[CONFIGURATIONS [DebuglRelease[...]]
[COMPONENT <component>]

[RENAME <name>] [OPTIONAL])

The FILES keyword is immediately followed by a list of ﬁles to be installed. Relative paths
are evaluated with respect to the current source directory. Files will be installed to the given
DESTINATION directory. For example, the command

:install (FILES my—api.h ${CMAKE_CURRENT_BINARY_DIR}/my—config.h
DESTINATION include)

Installs the ﬁle my—api . h from the source tree and the ﬁle my—config . h from the build tree
into the include directory under the installation preﬁx. By default installed ﬁles are given
pennﬁﬁonSOWNERAWRITE,OWNER_READ,GROUPVREAD,andeRLngREAD,unthminaybe
overridden by specifying the PERMISSIONS option. Consider the case in which we want to
install a global conﬁguration ﬁle on a UNIX system that is readable only by its owner (such
as root). We may accomplish this with the command

install (FILES my—rc DESTINATION /etc
PERMISSIONS OWNER_WRITE OWNER_READ)

which installs the ﬁle my— rc with owner read/write permission into the absolute path / etc.
The RENAME argument speciﬁes a name for an installed ﬁle that may be different from the

original ﬁle. Renaming is allowed only when a single ﬁle is installed by the command. For
example, the command

install(FILES version.h DESTINATION include RENAME my-version.h)

72 Writing CMakeLists Files

will install the ﬁle version . h ﬁom the source directory to include/my—version .h under
the installation preﬁx.

Projects may also install helper programs such as shell scripts or python scripts that are not
actually compiled as targets. These may be installed with the FILES signature using the
PERMISSIONS option to add execute permission. However this case is common enough to
justify a simpler interface. CMake provides the PROGRAMS signature for this purpose:

' install (PROGRAMS files... DESTINATION <dir>
‘ [PERMISSIONS permissions. . .]
[CONFIGURATIONS [DebuglRelease[...]]

[COMPONENT <component>]
[RENAME <name>] [OPTIONAL])

The PROGRAMS keyword is immediately followed by a list of scripts to be installed. This
command is identical to the FILES signature except that the default permissions additionally
include OWNER_EXECUTE, GROUP‘EXECUTE, and WORLDiEXECUTE. For example, we may
install a python utility script with the command

‘install (PROGRAMS my—util.py DESTINATION bin)

which installs my—util .py to the bin directory under the installation preﬁx and gives it
owner, group, and world read and execute permission plus owner write.

Projects may also provide a whole directory full of resource ﬁles such as icons or html
documentation. An entire directory may be installed using the DIRECTORY signature:

{install (DIRECTORY dirs... DESTINATION <dir>
[FILEiPERMISSIONS permissions...]
[DIRECTORYiPERMISSIONS permissions...]
[USEiSOURCEiPERMISSIONS]

[CONFIGURATIONS [DebuglRelease|...]]
[COMPONENT <Component>]

[[PATTERN <pattern> | REGEX <regex>]

[EXCLUDE] [PERMISSIONS permissions...]] [...])

The DIRECTORY keyword is immediately followed by a list of directories to be installed.
Relative paths are evaluated with respect to the current source directory. Each named
directory is installed to the destination directory. The last component of each input directory

Installing Files 73

name is appended to the destination directory as that directory is copied. For example, the
command

. install (DIRECTORY data/icons DESTINATION share/myproject)

will install the data/ icons directory from the source tree into share/myproject/icons
under the installation preﬁx. A trailing slash will leave the last component empty and install
the contents of the input directory to the destination. The command

install (DIRECTORY doc/html/ DESTINATION doc/myproject)

installs the contents of doc/html from the source directory into doc / myproj ect under the
installation preﬁx. If no input directory names are given, as in

install (DIRECTORY DESTINATION share/myproject/user)

the destination directory will be created but nothing will be installed into it.

Files installed by the DIRECTORY signature are given the same default permissions as the
FILES signature. Directories installed by the DIRECTORY signature are given the same default
permissions as the PROGRAMS signature. The FILE_PERMISSIONS and
DIRECTORYiPERMISSIONS options may be used to override these defaults. Consider the case
in which a directory full of example shell scripts is to be installed into a directory that is both
owner and group writable. We may use the command

L install (DIRECTORY data/scripts DESTINATION share/myproject
FILEAPERMISSIONS
OWNERﬁREAD OWNERiEXECUTE OWNERiWRITE
GROUPiREAD GROUP_EXECUTE
WORLDiREAD WORLDiEXECUTE
DIRECTORYiPERMISSIONS
OWNERiREAD OWNER_EXECUTE OWNER_WRITE
GROUPiREAD GROUP_EXECUTE GROUP_WRITE
WORLDiREAD WORLD_EXECUTE)

which installs the directory data/ scripts into share/myproj ect/scripts and sets the
desired permissions. In some cases a ﬁilly prepared input directory created by the project may
have the desired permissions already set. The U SE_SOURCE_PERMISSION S option tells
CMake to use the ﬁle and directory permissions from the input directory during installation. If

74 Writing CMakeLists Files

in the previous example the input directory were to have already been prepared with correct
permissions the following command may have been used instead.

install (DIRECTORY data/scripts DESTINATION share/myproject
USEiSOURCEgPERMISSIONS)

If the input directory to be installed is under source management, such as CVS, there may be
extra subdirectories in the input that we do not wish to install. There may also be speciﬁc ﬁles
which should not be installed, or be installed with different permissions, while most ﬁles get
the defaults. The PATTERN and REGEX options may be used for this purpose. A PATTERN
option is followed ﬁrst by a globbing pattern and then by an EXCLUDE or PERMISSIONS
option. A REGEX option is followed ﬁrst by a regular expression and then by EXCLUDE or
PERMISSIONS. The EXCLUDE option skips installation of those ﬁles or directories matching
the preceding pattern or expression, while the PERMISSIONS option assigns speciﬁc
permissions to them.

Each input ﬁle and directory is tested against the pattern or regular expression as a full path
with forward slashes. A pattern will match only complete ﬁle or directory names occurring at
the end of the full path while a regular expression may match any portion. For example, the
paﬁen1“foow’“dﬂiﬂawh‘iu/foo.txt”butnot“H./myfoo.txt”or“H./foo/bar.txt”
but the regular expression “foo” will match all of them.

Returning to the above example of installing an icons directory, consider the case in which the
input directory is managed by CVS and also contains some extra text ﬁles that we do not want
to install. The command

install (DIRECTORY data/icons DESTINATION share/myproject
PATTERN “CVS" EXCLUDE
PATTERN “*.txt" EXCLUDE)

installs the icons directory while ignoring any CVS directory or text ﬁle contained. The
equivalent command using the REGEX option is

install (DIRECTORY data/icons DESTINATION share/myproject
REGEX “/CVS$" EXCLUDE
REGEX “/[A/]*.txt$" EXCLUDE)

which uses ‘/ ’ and ‘$’ to constrain the match in the same way as the patterns. Consider a
similar case in which the input directory contains shell scripts and text ﬁles that we wish to
install with different permissions than the other ﬁles. The command

Installing Files 75

Einstall (DIRECTORY data/other/ DESTINATION share/myproject
‘ PATTERN “CVS" EXCLUDE
PATTERN “*.tXt"
PERMISSIONS OWNER_READ OWNERAWRITE
PATTERN “*.sh”
PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE)

will install the contents of data/other from the source directory to share/myproject
while ignoring CVS directories and giving speciﬁc permissions to .txt and . sh ﬁles.

Project installations may need to perform tasks other than just placing ﬁles in the installation
tree. Third—party packages may provide their own mechanisms to register new plugins which
must be invoked during project installation. The SCRIPT signature is provided for this

purpose:
yinstall (SCRIPT <file>)

The SCRIPT keyword is immediately followed by the name of a CMake script. CMake will
execute the script during installation. If the ﬁle name given is a relative path it will be
evaluated with respect to the current source directory. A simple use case is printing a message
during installation. We ﬁrst write a message . cma ke ﬁle containing the code

message (“Installing My Project”)
and then reference this script using the command
1install (SCRIPT message.cmake)

Custom installation scripts are not executed during the main CMakeLists ﬁle processing.
They are executed during the installation process itself. Variables and macros deﬁned in the
code containing the install (SCRIPT) call will not be accessible from the script. However
there are a few variables deﬁned during the script execution which may be used to get
information about the installation. The variable CMAKE_TNSTALL_PREFIX is set to the actual
installation preﬁx. This may be different ﬁom the corresponding cache variable value because
the installation scripts may be executed by a packaging tool that uses a different preﬁx. An
environment variable ENV{ DESTDIR} may be set by the user or packaging tool. Its value is
prepended to the installation preﬁx and to absolute installation paths to determine the location
to which ﬁles are installed. In order to reference an install location on disk the custom script
may use $ENV{DESTDIR} $ {CMAKE_INSTALL_PREFIX} as the top portion of the path. The
variable CMAKE_INSTALL_CONFIG_NAME is set to the name of the build conﬁguration

76 Writinq CMakeLists Files

currently being installed (Debug, Release, etc.). During component-speciﬁc installation the
variable CMAKEilNSTALL_COMPONENT is set to the name of the current component.

Custom installation scripts, as simple as the message above, may be more easily created with
the script code placed inline in the call to the INSTALL command. The CODE signature is
provided for this purpose:

install (CODE “<code>")

The CODE keyword is immediately followed by a string containing the code to place in the
installation script. An install-time message may be created using the command

install (CODE “MESSAGE(\”lnstalling My Project\”)")

which has the same effect as the message. cmake script but contains the code inline.

Installing Prerequisite Shared Libraries

Executables are ﬁequently built using shared libraries as building blocks. When you install
such an executable, you must also install its prerequisite shared libraries, called
“prerequisites” because the executable requires their presence in order to load and run
properly. The three main sources for shared libraries are the operating system itself, the build
products of your own project and third party libraries belonging to an external project. The
ones from the operating system may be relied upon to be present without installing anything:
they are on the base platform on which your executable runs. The build products in your own
project presumably have add_library build rules in the CMakeLists ﬁles, and so it should be
straightforward to create CMake install rules for them. It is the third party libraries that
frequently become a high maintenance item when there are more than a handful of them or
when the set of them ﬂuctuates from version to version of the third party project. Libraries
may be added, code may be reorganized, and the third party shared libraries themselves may
actually have additional prerequisites that are not obvious at ﬁrst glance.

CMake provides two modules to make it easier to deal with required shared libraries. The ﬁrst
module, GetPrerequisites.cmake, provides the get_prerequisites function to analyze and
classify the prerequisite shared libraries upon which an executable depends. Given an
executable ﬁle as input, it will produce a list of the shared libraries required to run that
executable, including any prerequisites of the discovered shared libraries themselves. it uses
native tools on the various underlying platforms to perform this analysis: dumpbin
(Windows), otool (Mac) and ldd (Linux). The second module, BundleUtilities.cmake,
provides the f ixup_bundle function to copy and ﬁxup prerequisite shared libraries using
well-deﬁned locations relative to the executable. For Mac bundle applications, it embeds the
libraries inside the bundle, ﬁxing them up with install_nameitool to make a self-

Installinq Files 77

contained unit. On Windows, it copies the libraries into the same directory with the
executable since executables will search in their own directories for their required DLLs.

The f ixupibundle ﬁanction helps you create relocatable install trees. Mac users appreciate
self—contained bundle applications: you can drag them anywhere, double click them and they
still work. They do not rely on anything being installed in a certain location other than the
operating system itself. Similarly Windows users without administrative privileges appreciate
a relocatable install tree where an executable and all of its required DLLs are installed in the
same directory and it works no matter where you install it. You can even move things around
after installing them and is will still work.

To use f ixup_bundle, ﬁrst install one of your executable targets. Then, conﬁgure a CMake
script that can be called at install time. Inside the conﬁgured CMake script, simply include
BundleUtilities and call the f ixup_bunolle function with appropriate arguments.

In CMakeLists.txt:

‘install (TARGETS myExecutable DESTINATION bin)

# To install, for example, MSVC runtime libraries:
include (InstallRequiredSystemLibraries)

# To install other/non—system 3rd party required libraries:
configure_file (
${CMAKE_CURRENT‘SOURCE7DIR}/FixBundle.cmake.in
$(CMAKE_CURRENT_BINARY7DIR}/FixBundle.cmake
@ONLY
)

install (SCRIPT ${CMAKEgCURRENTiBINARY_DIR}/FixBundle.cmake)

In FixBundle.cmake.in:

include (BundleUtilities)

# Set bundle to the full path name of the executable already
# existing in the install tree:

‘set (bundle
“${CMAKEiINSTALL_PREFIX}/myExecutable@CMAKE‘EXECUTABLEisUFFIX@”)

# Set other_libs to a list of full path names to additional
‘# libraries that cannot be reached by dependency analysis.
L # (Dynamically loaded PlugIns, for example.)

78 Writing CMakeLists Files

E set (otherﬁlibs W)

# Set dirs to a list of directories where prerequisite libraries
‘# may be found:
set (dirs “@LIBRARY_OUTPUT7PATH@”)

‘ fixup_bundle (“${bundle}” “${other_libs}” “${dirs}”)

You are responsible for verifying that you have permission to copy and distribute the
prerequisite shared libraries for your executable. Some libraries may have restrictive software
licenses that prohibit making copies a la f ixupibundle.

Exporting and Importing Targets

CMake 2.6 introduced support for exporting targets from one CMake—based project and
importing them into another. The main feature allowing this functionality is the notion of an
IMPORTED target. Here we present imported targets and then show how CMake ﬁles may be
generated by a project to export its targets for use by other projects.

Importing Targets

Imported targets are used to convert ﬁles outside of the project on disk into logical targets
inside a CMake project. They are created using the IMPORTED option to the
addiexecutable and add_library commands. No build ﬁles are generated for imported
targets. They are used simply for convenient, ﬂexible reference to outside executables and
libraries. Consider the following example which creates and uses an IMPORTED executable
target:

:add_executable (generator IMPORTED) # l
set_property (TARGET generator PROPERTY
IMPORTEDVLOCATION "/path/to/some7generator") # 2

add_custom7command (OUTPUT generated.c
COMMAND generator generated.c) # 3

‘add_executable (myexe srcl.c src2.c generated.c)

Line #1 creates a new CMake target called generator. Line #2 tells CMake the location of
the target on disk to import. Line #3 references the target in a custom command. Once CMake
is run the generated build system will contain a command line such as

_/path/to/some_generator /project/binary/dir/generated.c

Installing Files 79

in the rule to generate the source ﬁle. In a similar manner libraries ﬁom other projects may be
used through IMPORTED targets:

3 add_library (foo IMPORTED)
‘set_property (TARGET foo PROPERTY

IMPORTED_LOCATION "/path/to/libfoo.a")
Z add'executable (myexe srcl.c src2.c)
ftarget_link_libraries (myexe foo)

On Windows a .dll and its .lib import library may be imported together:

:add_library (bar IMPORTED)
rset_property (TARGET bar PROPERTY
: IMPORTED_LOCATION "c:/path/to/bar.dll")
tset_property (TARGET bar PROPERTY
IMPORTED‘IMPLIB "c:/path/to/bar.lib")
addiexecutable (myexe srcl.c src2.c)
ftarget_link41ibraries (myexe bar)

A library with multiple conﬁgurations may be imported with a single target:

ladd_library (foo IMPORTED)
:setgproperty (TARGET foo PROPERTY
IMPORTEDVLOCATION_RELEASE "C:/path/tO/foo.lib")
setiproperty (TARGET foo PROPERTY
‘ TMPORTEDvLOCATION_DEBUG "c : /path/to/foovd . lib ")
add_executable (myexe srcl.c scm.c)
ltarget_link_libraries (myexe foo)

The generated build system will link myexe to foo.lib when it is built in the release
conﬁguration and foo_d. lib when built in the debug conﬁguration.

Exporting Targets

Imported targets on their own are useﬁJl, but they still require the project that imports them to
know the locations of the target ﬁles on disk. The real power of imported targets is when the
project providing the target ﬁles also provides a ﬁle to help import them.

The install (TARGETS) and install (EXPORT) commands work together to install both a
target and a CMake ﬁle to help import it. For example, the code

3 add_executable (generator generator.c)

8O Writinq CMakeLists Files

 

1‘install (TARGETS generator DESTINATION lib/myproj/generators
. EXPORT myproj—targets)
install (EXPORT myproj~targets DESTINATION lib/myproj)

will install the two ﬁles

l<prefix>/lib/myproj/generators/generator
-<prefix>/lib/myproj/myproj—targets.Cmake

The ﬁrst is the regular executable named generator. The second ﬁle, myproj —
targets. cmake, is a CMake ﬁle designed to make it easy to import generator. This ﬁle
contains code such as

get*filename_component (_self "${CMAKE_CURRENT_LIST_FILE}" PATH)
:getAfilename_component (PREFIX "${gself}/../.." ABSOLUTE)
_add¥executable (generator IMPORTED)
setgproperty (TARGET generator PROPERTY
IMPORTED_LOCATION "${PREFIX}/lib/myproj/generators/generator")

(note that $ {PREFIX} is computed relative to the ﬁle location). An outside project may now
use generator as follows:

:include (${PREFIX}/lib/myproj/myproj—targets.cmake) # l
‘addgcustomgcommand (OUTPUT generated.c
COMMAND generator generated.c) # 2
add_executable (myexe srcl.c scm.c generated.c)

Line #1 loads the target import script (see section 5.7 to make this automatic). The script may
import any number of targets. Their locations are computed relative to the script location so
the install tree may be easily moved. Line #2 references the generator executable in a custom
command. The resulting build system will run the executable from its installed location.
Libraries may also be exported and imported:

add_library (foo STATIC fool.c)
install (TARGETS foo DESTINATION lib EXPORTS myproj-targets)
_install (EXPORT myproj—targets DESTINATION lib/myproj)

This installs the library and an import ﬁle referencing it. Outside projects may simply write

Installing Files 81

include (${PREFIX}/lib/myproj/myproj—targets.cmake)
jaddvexecutable (myexe srcl.c)
‘target_link_libraries (myexe foo)

and the executable will be linked to the library foo exported and installed by the original
project.

Any number of target installations may be associated with the same export name. The export
names are considered global so any directory may contribute a target installation. Only one
call to the install (EXPORT) command is needed to install an import ﬁle that references all
targets. Both of the examples above may be combined into a single export ﬁle, even if they
are in different subdirectories of the project as shown in the code below.

# A/CMakeLists.tXt
;addAexecutable (generator generator.c)
tinstall (TARGETS generator DESTINATION lib/myproj/generators
EXPORT myproj—targets)

‘# B/CMakeLists.txt
add_library (foo STATIC fool.c)
install (TARGETS foo DESTINATION lib EXPORTS myproj—targets)

L# Top CMakeLists.txt
addisubdirectory (A)
addisubdirectory (B)
(install (EXPORT myproj—targets DESTINATION lib/myproj)

Typically projects are built and installed before being used by an outside project. However in
some cases it is desirable to export targets directly from a build tree. The targets may then be
used by an outside project that references the build tree with no installation involved. The
export command is used to generate a ﬁle exporting targets from a project build tree. For
example, the code

add_executable (generator generator.c)
:export (TARGETS generator FILE myproj—exports.cmake)

will create a ﬁle in the project build tree called myproj —exports . cmake that contains the
required code to import the target. This ﬁle may be loaded by an outside project that is aware
of the project build tree in order to use the executable to generate a source ﬁle. An example
application of this feature is for building a generator executable on a host platform when cross
compiling. The project containing the generator executable may be built on the host platform
and then the project that is being cross-compiled for another platform may load it.

82 Writinq CMakeLists Files

4.12 Advanced Commands

There are a few commands that can be very useful but are not typically used in writing
CMakeLists ﬁles. This section will discuss a few of these commands and when they are
useful. First consider the add_dependencies command which creates a dependency
between two targets. CMake automatically creates dependencies between targets when it can
determine them. For example, CMake will automatically create a dependency for an
executable target that depends on a library target. The add_dependencies command is
typically used to specify inter target dependencies between targets where at least one of the
targets is a custom target (see section 6.4 for more information on custom targets).

The include_regular_expression command also relates to dependencies. This
command controls the regular expression that is used for tracing source code dependencies.
By default CMake will trace all the dependencies for a source ﬁle including system include
ﬁles such as stdio.h. If you specify a regular expression with the
includeﬂregularﬁexpression command that regular expression will be used to limit
what include ﬁles are processed. For example; if your software project’s include ﬁles all
started with the preﬁx foo (eg. fooMain.c fooStruct.h etc) then you could specify a
regular expression of “foo.*$ to limit the dependency checking to just the ﬁles of your
project.

Occasionally you might want to get a listing of all the source ﬁles that another source ﬁle
depends on. This is useful when you have a program that uses pieces of a large library but you
are not sure what pieces it is using. The output_required~files command will take a
source ﬁle and produce a list of all the other source ﬁles it depends on. You could then use
this list to produce a reduced version of the library that only contains the necessary ﬁles for
your program.

Some tools such as Rational Purify on the Sun platform are run by inserting an extra
command before the ﬁnal link step. So, instead of

‘CC foo.o -o foo
The link step would be
:purify CC foo.o —o foo

It is possible to do this with CMake. To run an extra program in front of the link line change
the rule variables CMAKE_CXX_LINK_EXECUTABLE, and CMAKE_C_LINK_EXECUTABLE. Rule
variables are described in chapter 11. The values for these variables are contained in the ﬁle
Modules/CMakeDefaultMakeRuleVariables.cmake,andtheyaresonmﬁnwsredeﬁned

Advanced Commands 83

in Modules/Platform/* . cmake. Make sure it is set after the PROJECT command in the
CMakeLists ﬁle. Here is a small example of using purify to link a program called foo:

:project (foo)

2 set (CMAKEiCXXiLINKJEXECUTABLE
"purif y s { CMAKEiCXXiLINKiEXECUTABLE} ")
addwexecutable (foo foo.cxx)

Of course, for a generic CMakeLists ﬁle you should have some if checks for the correct
platform. This will only work for the Makeﬁle generators because the rule variables are not
used by the IDE generators. Another option would be to use $(PURIFY) instead of plain
purify. This would pass through CMake into the Makeﬁle and be a make variable. The
variable could be deﬁned on the command line like this: make PURIFYZpurify. If not
speciﬁed then it would just use the regular rule for linking a C++ executable as PURIFY
would be expanded by make to nothing.

 

Chapter 5

 

System Inspection

This chapter will describe how you can use CMake to inspect the environment of the system
on which the software is being built. This is a critical factor in creating cross-platform
applications or libraries. It covers how to ﬁnd and use system and user installed header ﬁles
and libraries. It also covers some of the more advanced features of CMake including the
tryicompile and tryirun commands. These commands are extremely powerful tools for
determining the capabilities of the system and compiler that is hosting your software. This
chapter also describes how to generate conﬁgured ﬁles and how to cross compile with
CMake. Finally, the steps required to enable a project for the f ind_package command are
covered, explaining how to create a <Package>Config . cmake ﬁle and other required ﬁles.

5.1 Using Header Files and Libraries

Many C and C++ programs depend on external libraries. However, when it comes to the
practical aspects of compiling and linking a project, taking advantage of existing libraries can
be difﬁcult for both developers and users. Problems usually show up as soon as the software
is built on a system other than that on which it was developed. Assumptions regarding where
libraries and header ﬁles are located become obvious when they are not installed in the same
place on the new computer and the build system is unable to ﬁnd them. CMake has many
features to aid developers in the integration of external software libraries into a project.

The CMake commands that are most relevant to this type of integration are the f ind_f 1 le,
find_library, find_path, find_program, and find_package commands. For most C
and C++ libraries, a combination of find_library and findﬁpath will be enough to
compile and link with an installed library. f ind_library can be used to locate, or allow a

86 System Inspection

user to locate a library, and find_path can be used to ﬁnd the path to a representative
include ﬁle from the project. For example, if you wanted to link to the tiff library, you could
use the following commands in your CMakeLists.txt ﬁle:

;# find libtiff, looking in some standard places
find_library (TIFF_LIBRARY
,: NAMES tiff tiff2
PATHS /usr/local/lib /usr/lib
)

# find tiff.h looking in some standard places
‘ find_path (TIFF_INCLUDES tiff.h
/usr/local/include
/usr/include

)
includeAdirectories (${TIFFiINCLUDES})
gaddﬁexecutable (mytiff mytiff.c )

_targetﬁlinkwlibraries (myprogram ${TIFF_LIBRARY})

The ﬁrst command used is f ind_library which in this case will look for a library with the
name tiff or tiff2. The find_library command only requires the library’s base name
without any platform speciﬁc preﬁxes or sufﬁxes, such as lib and .dll. The appropriate
preﬁxes and sufﬁxes for the system running CMake will be added to the library name
automatically when CMake attempts to ﬁnd it. All the FIND_* commands will look in the
PATH environment variable. In addition, the commands allow the speciﬁcation of additional
search paths as arguments listed after the PATHS marker argument. As well as supporting
standard paths, windows registry entries and environment variables can be used to construct
search paths. The syntax for registry entries is the following:

[HKEY_CURRENT_USER\\Software\\Kitware\\Path;Buildl]

Because software can be installed in many different places, it is impossible for CMake to ﬁnd
the library every time, but most standard installations should be covered. The f ind_*
commands automatically create a cache variable so that users can override or specify the
location from the CMake GUI. This way if CMake is unable to locate the ﬁles it is looking for
users will still have an opportunity to specify them. If CMake does not ﬁnd a ﬁle, the value is
set to VAR-NOTFOUND. This value tells CMake that it should continue looking each time
CMake’s conﬁgure step is run. Note that in if statements, values of VAR—NOTFOUND will
evaluate as false.

System Properties 87

 

The next command used is find_path. This is a general purpose command that, in this
example, is used to locate a header ﬁle from the library. Header ﬁles and libraries are often
installed in different locations, and both locations are required to compile and link programs
that use them. f ind_path is similar to f ind_library, although it only supports one name.
It supports a list of search paths.

The next part of the CMakeLists ﬁle uses the variables created by the f ind_* commands.
The variables can be used Without checking for valid values as CMake will print an error
message notifying the user if any of the required variables have not been set. The user can
then set the cache values and reconﬁgure until the message goes away. Optionally, a
CMakeLists ﬁle could use the if command to use alternative libraries or options to build the
project without the library if it cannot be found.

From the above example you should be able to see how using the f ind_* commands can help
your software to compile on a wide variety of systems. It is worth noting that the f ind_*
commands search for a match starting with the ﬁrst argument and ﬁrst path. So when listing
paths and library names you should list your preferred paths and names ﬁrst. If there are
multiple versions of a library, and you would prefer tiff over tifﬂ, make sure you list them in
that order.

5.2 System Properties

Although it is a common practice in C and C++ code to add platform-speciﬁc code inside
preprocessor ifdef directives, for maximum portability this should be avoided. Software
should not be tuned to speciﬁc platforms with ifdefs, but rather to a canonical system
consisting of a set of features. Coding to speciﬁc systems makes the software less portable,
because systems and the features they support change with time, and even from system to
system. A feature that may not have worked on a platform in the past may be a required
feature for the platform in the future. The following code fragments illustrate the difference
between coding to a canonical system and a speciﬁc system:

.// coding to a feature

? #ifdef HAS_FOOBARVCALL
foobar();

?#else

: myfoobar();

_#endif

.// coding to specific platforms
i#if defined(SUN) && defined(HPUX) && Idefined(GNUC)
‘ foobar();
é#else
myfoobar();

88 System Inﬂection
##endif

The problem with the second approach is that the code will have to be modiﬁed for each new
platform on which the software is compiled. For example, a future version of SUN may no
longer have the foobar call. Using the HAS_FOOBAR!CALL approach, the software will work
as long as HAS_FOOBAR_CALL is deﬁned correctly, and this is where CMake can help. CMake
can be used to deﬁne HAS_FOOBAR_CALL correctly and automatically by making use of the
try_compile and trygrun commands. These commands can be used to compile and run
small test programs during the CMake conﬁgure step. The test programs will be sent to the
compiler that will be used to build the project, and if errors occur the feature can be disabled.
These commands require that you write a small C or C++ program to test the feature. For
example, to test if the foobar call is provided on the system, try compiling a simple program
that uses foobar. First write the simple test program (testNeedFoobar.c in this example) and
then add the CMake calls to the CMakeLists ﬁle to try compiling that code. If the compilation
works then HAS_FOOBAR_CALL will be set to true.

:——— testNeedFoobar.c —————

#include <foobar.h>
main()
Kl

foobar();

.——- testNeedFoobar.cmake ——-

'try_compile (HAS'FOOBAR_CALL
${CMAKEgBINARY’DIR}
${PROJECT_SOURCEVDIR}/testNeedFoobar.c
)

Now that HASiFOOBAR‘CALL is set correctly in CMake you can use it in your source code
through either the addidefinitions command or by conﬁguring a header ﬁle. We
recommend conﬁguring a header ﬁle as that ﬁle can be used by other projects that depend on
your library. This is discussed further in section 5.6.

Sometimes, just compiling a test program is not enough. In some cases, you may actually
want to compile and run a program to get its output. A good example of this is testing the byte
order of a machine. The following example shows how you can write a small program that
CMake will compile and then run to determine the byte order of a machine.

System Properties 89

—--— TestByteOrder.c ——————

‘int main () {
/* Are we most significant byte first or last */

union
{
long 1;
char c[sizeof (long)];
lu; ’
u.l = 1;
exit (u.c[sizeof (long) - 1] == 1);

i ----- TestByteOrder.cmake —————

tryirun (RUN_RESULT_VAR
COMPILEiRESULT_VAR
${CMAKEVBINARY_DIR}
S{PROJECTVSOURCEiDIR}/Modules/TestByteOrder.c
OUTPUTiVARIABLE OUTPUT
)

The return result of the run will go into RUN_RESULT7VAR and the result of the compile will
go into COMPILEiRESULT_\/AR, and any output from the run will go into OUTPUT. You can
use these variables to report debug information to the users of your project.

For small test programs the FILE command with the WRITE option can be used to create the
source ﬁle from the CMakeLists ﬁle. The following example tests the C compiler to verify
that it can be run.

file (WRITE
${CMAKE_BINARY7DIR}/CMakeTmp/testCCompiler.c
"int main(){return 0;}"

)

‘try*compile (CMAKE7C_COMPILERAWORKS
${CMAKE_BINARY7DIR}
${CMAKE_BINARY7DIR}/CMakeTmp/testCCompiler.c
OUTPUT_VARIABLE OUTPUT
)

90 Svstem Inspection

There are several predeﬁned try-run and try-compile macros in the CMa ke /Modules
directory, some of which are listed below. These macros allow some common checks to be
performed without having to create a source ﬁle for each test. For detailed documentation or
to see how these macros work look at the implementation ﬁles for them in the
CMake / Modules directory of your CMake installation. Many of these macros will look at the
current value of the CMAKE_REQUIREDﬁFLAGS and CMAKE_REQUIRED_LIBRARIES variables
to add additional compile ﬂags or link libraries to the test.

CheckFunctionExists.cmake

Checks to see if a C function is on a system. This macro takes two arguments, the
ﬁrst is the name of the function to check for. The second is the variable to store the
result into. This macro does use CMAKEiREQUIREDJELAGS and
CMAKE_REQUIRED_LIBRARIES if they are set.

ChecklncludeFile.cmake:

Checks for an include ﬁle on a system. This macro takes two arguments. The ﬁrst is
the include ﬁle to look for and the second is the variable to store the result into.
Additional CF lags can be passed in as a third argument or by setting
CMAKE_REQU IRED_FLAGS .

ChecklncludeFileCXXxmake

Check for an include ﬁle in a C++ program. This macro takes two arguments. The
ﬁrst is the include ﬁle to look for and the second is the variable to store the result
into. Additional CFlags can be passed in as a third argument.

ChecklncludeFiles.cmake

Check for a group of include ﬁles. This macro takes two arguments. The ﬁrst is the
include ﬁles to look for and the second is the variable to store the result into. This
macro does use CMAKE_REQUIRED_FLAGS if it is set. This macro is useful when a
header ﬁle you are interested in checking for is dependent on including another
header ﬁle ﬁrst.

CheckLibraryExists.cmake

Check to see if a library exists. This macro takes four arguments; the ﬁrst is the name
of the library to check for. The second is the name of a ﬁanction that should be in that
library. The third argument is the location of where the library should be found. The
fourth argument is a variable to store the result into. This macro uses
CMAKE_REQUIRED7FLAGS and CMAKE_REQUIRED_LIBRARIES if they are set.

CheckSymbolExists.cmake

Check to see if a symbol is deﬁned in a header ﬁle. This macro takes three
arguments. The ﬁrst argument is the symbol to look for. The second argument is a
list of header ﬁles to try including. The third argument is where the result is stored.

System Properties 91

This macro uses CMAKE_REQUIRED_FLAGS and CMAKE_REQUIREDALIBRARIES if
they are set.

CheckTypeSize.cmake

Determines the size in bytes of a variable type. This macro takes two arguments. The
ﬁrst argument is the type to evaluate. The second argument is where the result is
stored. Both CMAKE_REQUIREDVFLAGS and CMAKE_REQUIRED_LIBRARIES are
used if they are set.

CheckVariableExists.cmake

Checks to see if a global variable exists. This macro takes two arguments. The ﬁrst
argument is the variable to look for. The second argument is the variable to store the
result in. This macro will prototype the named variable and then try to use it. If the
test program compiles then the variable exists. This will only work for C variables.
This macro uses CMAKE_REQUIRED_FLAGS and CMAKE_REQUIRED_LIBRARIES if
they are set. 3

Consider the following example that shows a variety of these modules being used to compute
properties of the platform. At the beginning of the example four modules are loaded from
CMake. The remainder of the example uses the macros deﬁned in those modules to test for
header ﬁles, libraries, symbols, and type sizes respectively.

i# Include all the necessary files for macros
:include (ChecklncludeFiles)

linclude (CheckLibraryExists)

' include (CheckSymbolExists)

ginclude (CheckTypeSize)

j# Check for header files
_set (INCLUDES "")
CHECK_INCLUDE7FILES ("${INCLUDES};winsock.h" HAVE¥WINSOCK_H)

_ if (HAVE_WINSOCK_H)
‘ set (INCLUDES ${INCLUDES} winsock.h)
vendif (HAVE_WINSOCK_H)

‘CHECKiINCLUDE_FILES ("${INCLUDES};io.h" HAvniIogH)
:if (HAVE_IO_H)

i set (INCLUDES ${INCLUDES} io.h)

iendif (HAVE_IogH)

,# Check for all needed libraries
E set (LIBS "")
7CHECK_LIBRARY_EXISTS ("dl;${LIBS}" dlopen "" HAVE_LIBDL)

92 System Inspection

:if (HAVE!LIBDL)
a set (LIBS ${LIBS} dl)
endif (HAVE_LIBDL)

_CHECK_LIBRARY#EXISTS ("ucb;${LIBS}" gethostname "" HAVEiLIBUCB)
‘ if (HAVEiLIBUCB)

set (LIBS ${LIBS} ucb)
_endif (HAVE_LIBUCB)

# Add the libraries we found to the libraries to use when
f# looking for symbols with the CHECKiSYMBOL_EXISTS macro
;set (CMAKEiREQUIREDiLIBRARIES ${LIBS})

i# Check for some functions that are used
(CHECKiSYMBOLiEXISTS (socket "${INCLUDES}" HAVEVSOCKET)
:CHECKiSYMBOLiEXISTS (poll "${INCLUDES}" HAVEiPOLL)

‘# Various type sizes
lCHECKfTYPEfSIZE (int SIZEOFiINT)
_ CHECK_TYPE_SIZE (size_t SIZEOFﬁSlZEvT)

For more advanced try_compile and trywrun operations, it may be desirable to pass ﬂags
to the compiler, or to CMake. Both commands support the optional arguments CMAKEiFLAGS
and COMPILEiDEFINITIONS. CMAKE_FLAGS can be used to pass —DVAR: TYPE=VALUE ﬂags
to CMake. The value of COMPILEiDEFlNITIONS is passed directly to the compiler command
line.

5.3 Finding Packages

Many software projects provide tools and libraries meant as building blocks for other projects
and applications. CMake projects that depend on outside packages locate their dependencies
using the f ind_package command. A typical invocation is of the form

find_package(<Package> [version])

Where “<Package>” is the name ofthe package to be found, and “ [version] ” is an optional
version request (of the form major [ .minor. [patch] 1). See Appendix C — Listﬁle
Commands for the full command documentation. The command’s notion of a package is
distinct from that of CPaCk, which is meant for creating source and binary distributions and
installers.

Built—in Find Modules 93

The command operates in two modes: Module mode and Conf ig mode. In Module mode the
command searches for a find—module: a ﬁle named "Find<Package>.cmake". It looks
ﬁrst in the CMAKE_MODULE_PATH and then in the CMake installation. If a ﬁnd-module is
found, it is loaded to search for individual components of the package. Find—modules contain
package-speciﬁc knowledge of the libraries and other ﬁles they expect to ﬁnd, and internally
use commands like findilibrary to locate them. CMake provides ﬁnd-modules for many
common packages; see Appendix D — Selected Modules. Find-modules are tedious and
difﬁcult to write and maintain because they need very speciﬁc knowledge of every version of
the package to be found. '

The Conﬁg mode of f indipackage provides a powerﬁil alternative through cooperation
with the package to be found. It enters this mode after failing to locate a ﬁnd-module or when
explicitly requested by the caller. In Conﬁg mode the command searches for a package
configuration file: a ﬁle named “<Package>Config. omake” or “<package>—
config . cmake” that is provided by the package to be found. Given the name of a package,
the f ind#package command knows how to search deep inside installation preﬁxes for
locations like

i <prefix>/lib/<package>/<package>—config . cmake

(see documentation of find_package in Appendix C , Listﬁle Commands for a complete
list of locations). CMake creates a cache entry called “<Package>_DIR” to store the location
found or allow the user to set it. Since a package conﬁguration ﬁle comes with an installation
of its package, it knows exactly where to ﬁnd everything provided by the installation. Once
the f ind¥package command locates the ﬁle it provides the locations of package components
without any additional searching.

The “ [version] ” option asks findﬁpackage to locate a particular version of the package.
In Module mode, the command passes the request on to the ﬁnd-module. In Conﬁg mode the
command looks next to each candidate package conﬁguration ﬁle for a package version
file: a ﬁle named “<Package>Config\/ersion . cmake” 01' “<package>—config—
<version>.cmake”. The version ﬁle is loaded to test whether the package version is an
acceptable match for the version requested (see documentation of f ind#package for the
version ﬁle API speciﬁcation). If the version ﬁle claims compatibility the conﬁguration ﬁle is
accepted, otherwise it is ignored. This approach allows each project to deﬁne its own rules for
version compatibility.

5.4 Built-in Find Modules

CMake has many predeﬁned modules that can be found in the Modules subdirectory of
CMake. The modules can ﬁnd many common software packages. See Appendix D , Selected
Modules for a detailed list.

94 System Inspection

Each Find<xx> . cmake module deﬁnes a set of variables that will allow a project to use the
software package once it is found. Those variables all start with the name of the software
being found <XX>. With CMake we have tried to establish a convention for naming these
variables, but you should read the comments at the top of the module for a more deﬁnitive
answer. The following variables are used by convention when needed:

<XX>_INCLUDE__DIRS
Where to ﬁnd the package’s header ﬁles, typically <XX>.h, etc.

<XX>_LIBRARIES
The libraries to link against to use <XX>. These include full paths.

<XX>_DEFINITIONS

Preprocessor deﬁnitions to use when compiling code that uses <XX>.

<XX>_EXECUTABLE
Where to ﬁnd the <XX> tool that is part of the package.

<XX>_<YY>_EXECUTABLE
Where to ﬁnd the <YY> tool that comes with <XX>.

<XX>_ROOT_DIR

Where to ﬁnd the base directory of the installation of <XX>. This is useful for large
packages where you want to reference many ﬁles relative to a common base (or root)
directory.

<XX>_VERSION_<YY>

Version <YY> of the package was found if true. Authors of ﬁnd modules should
make sure at most one of these is ever true. For example TCLﬁVERSION_84

<XX>_<YY>_FOUND
If false, then the optional <YY> part of <XX> package is not available.

<XX>_FOUND

Set to false, or undeﬁned, if we haven't found or don't want to use <XX>.

Not all of the variables are present in each of the FindXX.cmake ﬁles. However, the
<XX>_FOUND should exist under most circumstances. If <XX> is a library, then
<XX>_LIBRARIES should also be deﬁned, and <XX>_INCLUDE_DIR should usually be
deﬁned.

How to Pass Parameters to a Compilation? 95

Modules can be included in a project either with the include command or the
f ind_package command.

jfind_packagel6penGLl
is equivalent to
E:lnélﬁdel$l¢MAhEgﬁObT}/Modules/Find6penGL.cmake)
and
3: lame}engage") ‘

If the project converts over to CMake for its build system, then the f ind_package will still
work if the package provides a <XX>Config . cmake ﬁle. How to create a CMake package is
described in section 5.7.

5.5 How to Pass Parameters to 3 Compilation?

Once you have determined all features of the system in which you are interested, it is time to
conﬁgure the software based on what has been found. There are two common ways to pass
this information to the compiler: on the compile line, and using a preconﬁgured header. The
ﬁrst way is to pass deﬁnitions on the compile line. A preprocessor deﬁnition can be passed to
the compiler from a CMakeLists ﬁle with the add_definitions command. For example, a
common practice in C code is to have the ability to selectively compile in/out debug
statements.

7 #ifdef DEBUGVBUILD
y printf("the value of v is %d", v);
:#endif

A CMake variable could be used to turn on or off debug builds using the OPTION command:
7 option (DEBUGiBUILD
‘ "Build with extra debug print messages.")
: if (DEBUGiBUILD)

‘ addidefinitions (—DDEBUGiBUILD)
_ endif (DEBUG_BUILD)

96 System Inspection

 

Another example wouldbe to tell the compiler the result of the previous HAS‘FOOBARiCALL
test that was discussed earlier in this chapter. You could do this with the following:

i f (HASgFOOBARﬁCALL)
addidefinitions (—DHASiFOOBARiCALL)
endif (HASiFOOBAR_CALL)

If you want to pass preprocessor deﬁnitions at a ﬁner level of granularity, you can use the
COMPILE_DEFINITIONS property that is deﬁned for directories, targets, and source ﬁles. For
example, the code

_add_library (mylib srcl.c src2.c)
addlexecutable (myexe main1.c)
set/property (
DIRECTORY
PROPERTY COMPILEHDEFINITIONS A AV:l
)

set)property (
TARGET mylib
PROPERTY COMPILE_DEFINITIONS B BV=2
)

setiproperty (
SOURCE srcl.c
PROPERTY COMPILE_DEFINITIONS C CV=3
)

will build the source ﬁles with these deﬁnitions:

srCl.C: -DA ~DAV=1 -DB -DBV=2 -DC -DCV=3

_src2.c: —DA —DAV:1 —DB —DBV=2

main2.c: —DA —DAV=l

When the addidefinitions command is called with ﬂags like "—DX" the deﬁnitions are
extracted and added to the current directory's COMPILEiDEFINIT IONS property. When a new
subdirectory is created with add‘subdi rectory the current state of the directory-level
property is used to initialize the same property in the subdirectory.

Note in the above example that the setﬁproperty command will actually set the property
and replace any existing value. The command provides the APPEND option to add more
deﬁnitions without removing existing ones. For example, the code

How to Configure a Header File 97

 

set*property (
SOURCE srcl.c
APPEND PROPERTY COMPILE‘DEFINITIONS D DV=4
)

will add the deﬁnitions "-DD —DDv=4" when building srcl.c. Deﬁnitions may also be
added on a per-conﬁguration basis using the COMPILE_DEFINITIONSi<CONFIG> property.
For example, the code

:set_property (
TARGET mylib
PROPERTY COMPILERDEFINITICNS-DEBUG MYLIBWDEBUGiMODE
)

will build sources in mylib with —DMYLIB_DEBUG_MODE only when compiling in a Debug
conﬁguration.

The second approach for passing deﬁnitions to source code is to conﬁgure a header ﬁle. For
maximum portability of a toolkit, it is recommended that —D options are not required for the
compiler command line. Instead of command line options, CMake can be used to conﬁgure a
header ﬁle that applications can include. The header ﬁle will include all of the #define
macros needed to build the project. The problem with using compile line deﬁnitions can be
seen when building an application that in turn uses a library. If building the library correctly
relies on compile line deﬁnitions, then chances are that an application that uses the library
will also require the exact same set of compile line deﬁnitions. This puts a large burden on the
application writer to make sure they add the correct ﬂags to match the library. If instead the
library’s build process conﬁgures a header ﬁle with all of the required deﬁnitions, then any
application that uses the library will automatically get the correct deﬁnitions when that header
ﬁle is included. A deﬁnition can often change the size of a structure or class, and if the
macros are not exactly the same during the build process of the library and the application
linking to the library, the application may reference the “wrong part” of a class or struct and
crash unexpectedly.

5.6 How to Configure a Header File

Hopeﬁilly we have convinced you that conﬁgured header ﬁles are the right choice for most
software projects. To conﬁgure a ﬁle with CMake the configure_file command is used.
This command requires an input ﬁle that is parsed by CMake which then produces an output
ﬁle with all variables expanded or replaced. There are three ways to specify a variable in an
input ﬁle for configure#file.

98 System Inspection

ii#cmatedefine VABiABLEW
If VARIABLE is true, then the result Will be:
g#define VARIABLETi I
If VARIABLE is false, then the result will be:
‘ /*7 wide: VA‘RJIVABiLEH V- A
${VARIABLE}

This is simply replaced by the value of VARIABLE.

@VARIABLE@
This is simply replaced by the value of VARIABLE.

Since the ${} syntax is commonly used by other languages, there is a way to tell the
configure_file command to only expand variables using the @var@ syntax. This is done
by passing the @ONLY option to the command. This is useful if you are conﬁguring a script
that may contain $ {var} strings that you want to preserve. This is important because CMake
will replace all occurrences of $ {var} with the empty string if var is not deﬁned in CMake.

The following example conﬁgures a .h ﬁle for a project that contains preprocessor variables.
The ﬁrst deﬁnition indicates if the FOOBAR call exists in the library, and the next one contains
the path to the build tree.

'———— CMakeLists.txt file —————

Configure a file from the source tree
called projectConfigure.h.in and put
the resulting configured file in the build

# # # #

tree and call it projectConfigure.h

configureﬂfile (
${PROJECTASOURCE_DIR}/projectConfigure.h.in
$ { PROJECTﬂBINARYhDIR} /proj ectConfigure .h)

Creating CMake Package Configuration Files 99

 

i ————— projectConfigure.h.in file ——————

{/* define a variable to tell the code if the */
;/* foobar call is available on this system */
-#cmakedefine HAS_FOOBAR_CALL

i/* define a variable with the path to the */
‘/* build directory */
‘ #define PROJECT¥BINARY7DIR "${PROJECT_BINARY_DIR}"

It is important to conﬁgure ﬁles into the binary tree, not the source tree. A single source tree
may be shared by multiple build trees or platforms. By conﬁguring ﬁles into the binary tree
the differences between builds or platforms will be kept isolated in the build tree, Where it Will
not corrupt other builds. This means that you will need to include the directory of the build
tree where you conﬁgured the header ﬁle into the project’s list of include directories using the
includeﬁdirectoriesconnnand

5.7 Creating CMake Package Configuration Files

Projects must provide package conﬁguration ﬁles so that outside applications can ﬁnd them.
Consider a simple project “Gromit” providing an executable to generate source code and a
library against Which the generated code must link. The CMakeLists . txt ﬁle might start
with:

cmake_minimum_required (VERSION 2.6.3)
rproject (Gromit C)
rset (version 1.0)

# Create library and executable.
yadd_library (gromit STATIC gromit.c gromit.h)
,add_executable (gromit—gen gromit—gen.c)

In order to install Gromit and export its targets for use by outside projects, one adds the code

‘# Install and export the targets.
install (FILES gromit.h DESTINATION include/gromit—${version})
‘install (TARGETS gromit gromit—gen
DESTINATION lib/gromit—${version}
: EXPORT gromit—targets)
:install (EXPORT gromit—targets
DESTINATION lib/gromit-${version})

100 System Inspection

as described in Section 0. Finally, Gromit must provide a package conﬁguration ﬁle in its
installation tree so that outside projects can locate it with f indgpac kage:

1# Create and install package configuration and version files.

Lconfigureifile (
${Gromit_SOURCE#DIR}/pkg/gromit—config.cmake.in
${Gromit_BINARY#DIR}/pkg/gromit—config.cmake @ONLY)

configureifile (
${Gromit_SOURCE#DIR}/gromit—config-version.cmake.in
${Gromit_BINARY#DIR}/gromit—config—version.cmake @ONLY)

install (FILES ${Gromit_BINARY_DIR}/pkg/gromit—config.cmake
I ${GromitiBINARY_DIR}/gromit-config—version.cmake
DESTINATION lib/gromit—${version})

This code conﬁgures and installs the package conﬁguration ﬁle and a corresponding package
version ﬁle. The package conﬁguration input ﬁle gromit—con fig . cmake . in has the code,

# Compute installation prefix relative to this file.
:get_filename_component (_dir "${CMAKE_CURRENT_LIST_FTLE}" PATH)
get_filename_component (_prefix "${_dir}/../.." ABSOLUTE)

# Import the targets.
include ("${_prefix}/lib/gromit—@version@/gromit—targets.cmake")

# Report other information.
set (gromit_INCLUDE_DTRS "${_prefix}/include/gromit-@version@")

After installation the conﬁgured package conﬁguration ﬁle gromit—config . cmake knows
the locations of other installed ﬁles relative to itself. The corresponding package version ﬁle
is conﬁgured from its input ﬁle gromit—config—version . cmake . in which contains code
such as,

set (PACKAGEﬁVERSION "@version@")
if (NOT "${PACKAGE_FIND7VERSION}" VERSION_GREATER "@Version@")
set (PACKAGEvVERSION_COMPATIBLE l) # compatible with older
if ("${PACKAGEﬁFIND_VERSION}" VERSION_EQUAL "@Version@")
set (PACKAGEﬁVERSION‘EXACT l) # exact match for this version
endif 0
endif 0

Creating CMake Paokaqe Configuration Files 101

 

' An application that uses the Gromit package might create a CMake ﬁle that looks like this:

Ecmake_minimum_required (VERSION 2.6.3)
‘project (MyProject C)

findgpackage (gromit 1.0 REQUIRED)
; include_directories ($(gromit_INCLUDE_DIRS})
:# run imported executable
' add_custom_command (OUTPUT generated.c
COMMAND gromit—gen generated.c)
: add_executable (myexe generated.c)
itarget_link_libraries (myexe gromit) # link to imported library

The call to f ind_package locates an installation of Gromit or terminates with an error
message if none can be found (due to REQUIRED). After the command succeeds, the Gromit
package conﬁguration ﬁle gromit—config . cma ke has been loaded, so Gromit targets have
been imported and variables like gromit_lNCLUDE_DIRS have been deﬁned.

The above example creates a package conﬁguration ﬁle and places it in the install tree.
One may also create a package conﬁguration ﬁle in the build tree to allow applications to
use the project without installation. In order to do this, one extends Gromit’s CMake ﬁle with
the code:

\ # Make project useable from build tree.

: export (TARGETS gromit gromit—gen FILE gromit—targets.cmake)
configure¥file (${Gromit_SOURCE_DIR}/gromit—config.cmake.in

: ${GromitﬁBINARY_DIR}/gromit—config.cmake @ONLY)

Thﬁ configuregfile can imes a dﬁﬁﬂentinput ﬁb, gromit—config.cmake.in,
containing

:# Import the targets.
include("@Gromit_BINARY_DIR@/gromit—targets.cmake")

# Report other information.
set(gromit_INCLUDE_DIRS "@Gromit_SOURCE_DIR@")

The package conﬁguration ﬁle gromit—con fig. cmake placed in the build tree provides the
same information to an outside project as that in the install tree, but refers to ﬁles in the
source and build trees. It shares an identical package version ﬁle gromit—config—
version. cmake with that placed in the install tree.

 

Chapter 6

 

Custom Commands and Targets

Frequently, the build process for a soﬁware project goes beyond simply compiling libraries
and executables. In many cases additional tasks may be required during or after the build
process. Common examples include: compiling documentation using a documentation
package, generating source ﬁles by running another executable, generating ﬁles using tools
for which CMake doesn’t have rules (such as lex, and yacc), moving the resulting
executables, post processing the executable, etc. CMake supports these additional tasks using
custom commands and custom targets. This chapter will describe how to use custom
commands and targets to perform complex tasks that CMake does not inherently support.

6.1 Portable Custom Commands

Before going into detail on how to use custom commands, we will discuss how to deal with
some of their portability issues. Custom commands typically involve running programs with
ﬁles as inputs or outputs. Even a simple command such as copying a ﬁle can be tricky to do in
a cross-platform way. For example, copying a ﬁle on UNIX is done with the cp command,
while on windows it is done with the copy command. To make matters worse, frequently the
names of the ﬁles will change on different platforms. Executables on Windows end with .exe
while on UNIX they do not. Even between UNIX implementations there are differences such
as what extensions are used for shared libraries; .so, .51, .dylib, etc.

CMake provides two main tools for handling these differences. The ﬁrst is the 7E option
(short for execute) to cmake. When the cmake executable is passed the ~E option it acts as a
general purpose cross-platform utility command. The arguments following the —E option
indicate what cma ke should do. Some of the options include:

104 Custom Commands and Targets

chdir dir command args

Changes the current directory to dir and then execute the command with the
provided arguments.

copy ﬁle destination
Copies a ﬁle from one directory or ﬁlename to another.

c0py_if_different in-file out-ﬁle

copy_if_different ﬁrst checks to see if the ﬁles are different before copying them.
copy_if_different is critical in many rules since the build process is based on ﬁle
modiﬁcation times. If the copied ﬁle is used as the input to another build rule then
copy_if_different can eliminate unnecessary recompilations.

c0py_direct0ry source destination

This option copies the source directory including any subdirectories to the
destination directory.

remove ﬁle1 ﬁle2
Removes the listed ﬁles from the disk.

echo string

Echos a string to the console. This is useful for providing output during the build
process.

time command args

Runs the command and times its execution.

These options provide a platform independent way to perform a few common tasks. The
cmake executable can be referenced by using the CMAKERCOMMAND variable in your
CMakeLists ﬁles as later examples will show.

The second tool CMake provides to address portability issues is a number of variables
describing the characteristics of the platform. While most of these are covered in Appendix A
- Variables, some are particularly useful for custom commands.

EXE_EXTENSION

This is the ﬁle extension for executables. Typically nothing on UNIX and .exe on
Windows

CMAKE_CFG_INTDIR

Development environments such as Visual Studio and Xcode use subdirectories
based on the build type selected, such as Release or Debug. When performing a

Using add custom command on a Target 105

custom command on a library, executable or object ﬁle you will typically need the
ﬁlll path to the ﬁle. CMAKE_CFG_INTDIR on UNIX will typically be " . /" while for
Visual Studio it Will be set to "$ (INTDIR) / ", which at build time will be replaced
by the selected conﬁguration.

CMAKE_CURRENT_BINARY_DIR

This is the full path to the output directory associated with the current CMakeLists
ﬁle. This may be different from PROJECTWBINARYJDIR which is the full path to the
top of the current project’s binary tree.

CMAKE_CURRENT_SOURCE_DIR

This is the full path to the source directory associated with the current CMakeLists
ﬁle. This may be different from PROJECT¥SOURCE¥DIR which is the full path to the
top of the current project’s source tree.

EXECUTABLE_OUTPUT_PATH

Some projects specify a directory into which all the executables should be built. This
variable, if deﬁned, holds the full path to that directory.

LIBRARY_OUTPUT_PATH

Some projects specify a directory into which all the libraries should be built. This
variable, if deﬁned, holds the full path to that directory.

There are also a series of variables such as CMAKE_SHARED_MODULE_PREFIX and ...S_UFFIX
that describe the current platform’s preﬁx and sufﬁx for that type of ﬁle. These variables are
deﬁned for SHARED_MODULE, SHARED_LIBRARY, and LIBRARY. Using these variables, you
can typically construct the full path to any CMake generated ﬁle that you need to. For
libraries and executable targets you can also use get_target_property with the
LOCATION argument to get the full path to the target.

CMake doesn’t limit you to using cmake 7E in all your commands. You can use any
command that you like, although you should consider portability issues when doing it. A
common practice is to use f iridiprogram to ﬁnd an executable (perl for example), and then
use that executable in your custom commands.

6.2 Using add_custom_command on a Target

Now we will consider the signature for addicustomicommand. In Makeﬁle terminology
add_customicommand adds a rule to a Makeﬁle. For those more familiar With Visual
Studio, it adds a custom build step to a ﬁle. addicustomﬁcommand has two main signatures,
one for adding a custom command to a target and one for adding a custom command to build
a ﬁle. When adding a custom command to a target the signature is as follows:

106 Custom Commands and Tarqets

3 add_customﬁcommand (
TARGET target
PRE‘BUILD I PREiLINK I POSTﬁBUILD
COMMAND command [ARGS argl argZ arg3 m]
[COMMAND command [ARGS argl arg2 arg3 m] m]
[COMMENT comment]
)

The target is the name of a CMake target (executable, library, or custom) to which you want
to add the custom command. There is a choice of when the custom command should be
executed. PREiBUILD indicates that the command should be executed before any other
dependencies for the target are built. PRE_LINK indicates that the command should be
executed alter the dependencies are all built, but before the actual link command.
POST_BUILD indicates that the custom command should be executed after the target has been
built. The COMMAND argument is the command (executable) to run and ARGS provides an
optional list of arguments to the command. Finally the COMMENT argument can be used to
provide a quoted string to be used as output when this custom command is run. This is useﬁil
if you want to provide some feedback or documentation on what is happening during the
build. You can specify as many commands as you want fora custom command. They will be
executed in the order speciﬁed.

How to Copy an Executable Once it is Built?

Now let us consider a simple custom command for copying an executable once it has been
built.

# first define the executable target as usual
add_executable (Foo bar.c)

# get where the executable will be located
_getitargetﬁproperty (EXEiLOC Foo LOCATION)

# then add the custom command to copy it
addicustomicommand (
TARGET Foo
POSTiBUILD
COMMAND ${CMAKE_COMMAND}
ARGS —E copy ${EXE7LOC} /testing_department/files
)

The ﬁrst command in this example is the standard command for creating an executable from a
list of source ﬁles. In this case an executable named Foo is created from the source ﬁle
bar.c. The next command is get¥target_property which will set the variable called

Using add custom command to Generate a File 107

 

EXE_LOC to where the executable will be built. Next is the add#custom_command
invocation. In this case the target is simply F00 and we are adding a post build command. The
command to execute is cmake which has its full path speciﬁed in the CMAKE*COMMAND
variable. Its arguments are "—E copy" and the source and destination locations. In this case it
will copy the Foo executable from where it was built into the
/testing_department/ files directory. Note that the TARGET parameter accepts a
CMake target (Foo in this example), but most commands such as cmake —E copy will
require the full path to the executable which can be retrieved using GET_TARGE T_PROPERTY.

6.3 Using add_custom_command to Generate a File

The second use for add_custom_command is to add a rule for how to build an output ﬁle. In
this case the rule provided will replace any current rules for building that ﬁle. The signature is
as follows: I
: add_custom_command (OUTPUT outputl [output2 ...]

COMMAND command [ARGS large. . . ]]

[COMMAND command [ARGS argl arg2 arg3 ml ...]

[MAINiDEPENDENCY depend]

[DEPENDS [depends . . . ] ]

[COMMENT comment]

)

The OUTPUT is the ﬁle (or ﬁles) that will result from running this custom command, the
COMMAND and ARGS parameters are the command to execute and the arguments to pass to it.
As with the prior signature you can have as many commands as you wish. The DEPENDS are
ﬁles or executables on which this custom command depends. If any of these dependencies
change this custom command will re-execute. The MAIN_DEPENDENCY is an optional
argument that acts as a regular dependency and under Visual Studio it provides a suggestion
for what ﬁle to hang this custom command onto. If the MAIN_DEPENDENCY is not speciﬁed
then one will be created automatically by CMake. The MAIN_DEPENDENCY should not be a
regular .0 or .cxx ﬁle since the custom command will override the default build rule for the
ﬁle. Finally the optional COMMENT is a comment that may be used by some generators to
provide additional information during the build process.

Using an Executable to Build a Source File

Sometimes a software project builds an executable, which is then used for generating source
ﬁles that are then used to build other executables or libraries. This may sound like an odd
case, but it occurs quite frequently. One example is the build process for the TIFF library,
which creates an executable that is then run to generate a source ﬁle that has system speciﬁc
information in it. This ﬁle is then used as a source ﬁle in building the main TIFF library.
Another example is the Visualization Toolkit that builds an executable called vtkWrapTcl

108 Custom Commands and Targets

that wraps C++ classes into Tcl. The executable is built and then used to create more source
ﬁles for the build process.

‘###################################################
# Test using a compiled program to create a file
_####################################################

' -# add the executable that will create the file
# build creator executable from creator.cxx
iadd_executable (creator creator.cxx)

get_target_property (creator EXE_LOC LOCATION)

# add the custom command to produce createdrc
add_custom_commahd ( /
OUTPUT ${PROJECTUBINARY_DIR}/created.c
DEPENDS creator
COMMAND ${EXE_LOC}
ARGS ${PROJECTABINARY_DIR}/created.c
)

# add an executable that uses created.c
add_executable (Foo ${PROJECT_BINARY_DIR}/created.c)

The ﬁrst part of this example produces the creator executable from the source ﬁle
creator. cxx. The custom command then sets up a rule for producing the source ﬁle
created.c by running the executable creator. The custom command depends on the
creator target and writes its result into the output tree (PROJECT_BINARY_DIR). Finally, an
executable target called Foo is added that is built using the created. c source ﬁle. CMake
will create all the required rules in the Makeﬁle (or Visual Studio workspace) such that when
you build the project, ﬁrst the creator executable will be built, then it will be run to create
created. c, which will then be used to build the Foo executable.

6.4 Adding a Custom Target

In the discussion so far CMake targets have generally referred to executables and libraries.
CMake supports a more general notion of targets, called custom targets, that can be used
whenever you want the notion of a target but the end product will not be a library or
executable. Examples of custom targets include targets to build documentation, run tests, or
update web pages. To add a custom target you use the add_custom‘target command with
the following signature:

The Enable Language Process 243

 

S {CMAKEﬁSYSTEM'PROCESSOR} . cmake if it exists, and after that
s {CMAKEﬁSYSTEMVNAMEl—$ {COMPILER_ID}—LANG.cmake. In these ﬁle names
COMPILERﬂID references the compiler identiﬁcation determined as described above. The
CMake(LANG)Information.cmake ﬁle contains default rules for creating executables,
libraries, and object ﬁles on most UNIX systems. The defaults can be overridden by setting
values in either 3 {CMAKEASYSTEMENAME} .cmake or ${CMAKE¥SYSTEMﬁNAME}—
$ {COMPILERAID} —LANG. cmake.

S { CMAKE_SYSTEM_NAME } ~$ {COMPILERVID } —LANG—

$ { CMAKE_SYSTEM_PROCESSOR} . cmake is intended to be used only for cross compiling, it is
loaded before $ { CMAKE¥SYSTEM7NAME } —$ {COMPILER¥ID} —LANG . cmake, so variables can
be set up which can then be used in the rule variables.

In addition to the ﬁles with the COMPILER_ID in their name, CMake also supports these ﬁles
using the COMPILER_BASE_NAME. COMPILER_BASE_NAME is the name of the compiler with
no path information. For example cl would be the COMPILER_BASE_NAME for the Microsoft
Windows compiler, and Windows—cl . cmake would be loaded. If a COMPILER_ID exists, it
will be preferred over the COMPILER_BASE_NAME, since on one side the same compiler can
have different names, but there can be also different compilers all with the same name. This
means, if

f K$y { CMAKE_éYSTEM_hlAldEl} ~$ iC’OMPILER;Ib } ~iIiANG-K
i’KlFMAKE—SYSTEM—PROQE530er 9?“?ke.
was not found, CMake tries
aerm_s%s:z»4;m4s;rcie>me:mé_fmsaw (we?
and if
e acm;sxsma.im as; i, eoMmER;mae’mc 7 we "
was not found, CMake tries
s g;,CLMAKa'SaT‘E‘nma sl‘gotmaagtswtllE} .'

CMake (LANG) Information . cmake and associated Platform ﬁles deﬁne special CMake
variables, called rule variables. A rule variable consists of a list of commands separated by
spaces. The commands are enclosed by quotes. In addition to the normal variable expansion
performed by CMake, some special tag variables are expanded by the Makeﬁle generator. Tag

244 Portinq CMake to New Platforms and Lanquaqes

variables have the syntax of <NAME> where NAME is the name of the variable. An example
rule variable is CMAKE_CXX_CREATE_SHARED_LIBRARY, and the default setting is

set (CMAKE_CXX_CREATE4SHARED~LIBRARY
"<CMAKEicxngOMPILER> <CMAKE§HARED_LIBRARY_CXX~FLAGS>
<LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_CXXVFLAGS>
<CMAKEgSHAREngLIBRARY_sONAME_CXXgFLAG><TARGETVSONAME> —o
<TARGET> <OBJECTS> <LINK_LIBRARIES>")

At this point, CMake has determined the system it is running on, the tools it will be using to
compile the enabled languages, and the rules to use the tools. This means there is enough
information for CMake to perform a try-compile. CMake will now test the detected compilers
for each enabled language by loading CMakeTest (LANG) Compiler.cmake. This ﬁle will
usually run a try—compile on a simple source ﬁle for the given language to make sure the
chosen compiler actually works.

Once the platform has been determined, and the compilers have been tested, CMake loads a
few more ﬁles that can be used to change some of the computed values. The ﬁrst ﬁle that is
loaded is CMake (PROJECTNAME) Compatibility.cmake where PROJECTNAME is the name
given to the top level PROJECT command in the project. The project compatibility ﬁle is used
to add backwards compatibility ﬁxes into CMake. For example, if a new version of CMake
fails to build a project that the previous version of CMake could build, then ﬁxes can be
added on a per project basis to CMake. The last ﬁle that is loaded is
$ { CMAKE!USER_MAKE_RULES_OVERRI DE }. This ﬁle is an optionally user supplied variable,
that can allow a project to make very speciﬁc platform based changes to the build rules.

11.3 Porting to a New Platform

Many common platforms are already supported by CMake. However, you may come across a
compiler or platform that has not yet been used. If the compiler uses an Integrated
Development Environment (IDE), then you will have to extend CMake from the C++ level.
However, if the compiler supports a standard make program, then you can specify in CMake
the rules to use to compile object code and build libraries by creating CMake conﬁguration
ﬁles. These ﬁles are written using the CMake language with a few special tags that are
expanded when the Makeﬁles are created by CMake. If you run CMake on your system and
get a message like the following, you will want to read how to create platform speciﬁc
settings.

System is unknown to cmake, create:

: Modules/Platform/MySystem.cmake

to use this system, please send your config file to
: cmake@www.cmake.org so it can be added to cmake

Porting to a New Platform 245

At a minimum you will need to create the Platform/$ {CMAKE_SYSTEM¥NAME} .cmake ﬁle
for the new platform. Depending on the tools for the platform, you may also want to create
Platform/${CMAKE‘SYSTEM_NAME}-${COMPILER_BASE¥NAME}.cmake. On Inoﬁ
systems, there is a vendor compiler and the GNU compiler. The rules for both of these
compilers can be put in Platform/s{CMAKE_SYSTEM¥NAME} .cmake instead of creating
separate ﬁles for each of the compilers. For most new systems or compilers, if they follow the
basic UNIX compiler ﬂags, you will only need to specify the system speciﬁc ﬂags for shared
library and module creation.

The following example is from Platform/IRIX. cmake. This ﬁle speciﬁes several ﬂags, and
also one CMake rule variable. The rule variable tells CMake how to use the IRIX CC
compiler to create a static library, which is required for template instantiation to work with
IRIX CC.

# there is no —ldl required on this system
‘ set (CMAKE¥DL7LIBS "")
# Specify the flag to create a shared 0 library

set (CMAKEiSHAREDiLIBRARYiCREATEycgrLAGs
"—shared —rdata!shared")

# Specify the flag to create a shared c++ library
set (CMAKEASHAREDALIBRARY_CREATE_CXX_FLAGS
' ”—shared -rdataishared")

# specify the flag to specify run time paths for shared
I# libraries —rpath
. set (CMAKE_SHARED‘LIBRARYiRUNTIMEpCiFLAG "—Wl,-rpath,")

‘# specify a separator for paths on the —rpath, if empty
‘# then —rpath will be repeated.
set (CMAKEﬁsHAREDVLIBRARyiRUNTIMEgCyFLAGASEP "")

# if the compiler is not GNU, then specify the initial flags
3‘ if (NOT CMAKEyCOMPILERyISﬁNUCXX)
# use the CC compiler to create static library
set (CMAKEiCXX¥CREATE_STATIC_LIBRARY
"<CMAKE7CXX~COMPILER> —ar -0 <TARGET> <OBJECTS>")

# initializes flags for the native compiler

set (CMAKE_CXXVFLAGSAINIT "")

set (CMAKE7CXX_FLAGS_DEBUGvINIT "—g")

set (CMAKEACXX_FLAGSRMINSIZEREL‘INIT "~03 -DNDEBUG")
set (CMAKE_CXX#FLAGS_RELEASE~INIT "—OZ —DNDEBUG")

246 Porting CMake to New Platforms and Lanquaqes

set (CMAKE_CXX_FLAGS_RELWITHDEBINFO_INIT "—02")
iendif (NOT CMAKE_COMPILER_IS_GNUCXX)

11.4 Adding a New Language

In addition to porting CMake to new platforms a user may want to add a new language. This
can be done either through the use of custom commands, or by deﬁning a new language for
CMake. Once a new language is deﬁned, the standard add_library and add_executable
commands can be used to create libraries and executables for the new langiage. To add a new
language, you need to create four ﬁles. The name LANG has to match in exact case the name
used in the PROJECT command to enable the language. For example Fortran has the ﬁle
CMakeDeterminFortranCompiler . cmake, and it is enabled With a call like this project
(f Fortran) . The four ﬁles are as follows:

CMakeDetermine(LANG)Compiler.cmake

This ﬁle will ﬁnd the path to the compiler for LANG and then conﬁgure
CMake(LANG)Compiler.cmake.in.

CMake(LANG)Compiler.cmake.in

This ﬁle should be used as input to a conﬁgure ﬁle call in the
CMakeDetermine(LANG)Compiler.cmake ﬁle. It is used to store compiler
information and is copied down into try—compile directories so that try compiles do
not need to re-determine and test the LANG.

CMakeTest(LANG)C0mpiler.cmake

This should use a try compile command to make sure the compiler and tools are
working. If the tools are working, the following variable should be set in this way:

set (CMAKE_(LANG)_COMPILER_WORKS l CACHE INTERNAL "")

CMake(LANG)Inf0rmation.cmake

Set values for the following rule variables for LANG:

CMAKE_(LANG)_CREATE_SHARED_LIBRARY
CMAKE_(LANG)_CREATE78HAREDIMODULE
CMAKE_(LANG)_CREATE_STATIC_LIBRARY
CMAKEr(LANG)_COMPILE_OBJECT
CMAKE_(LANG)_LINK_EXECUTABLE

Rule Variable Listinq 247

11.5 Rule Variable Listing

For each language that CMake supports, the following rule variables are expanded into build
Makeﬁles at generation time. LANG is the name used in the PROJECT (name LANG)
command. CMake currently supports CXX, C, Fortran, and Java as values for LANG.

General Tag Variables

The following set of variables will be expanded by CMake.

<TARGET>
The name of the target being built (this may be a full path).

<TARGET_QUOTED>
The name of the target being built (this may be a full path) double quoted.

<TARGET_BASE>
This is replaced by the name of the target without a sufﬁx.

<TARGET_SONAME>
This is replaced by

CMAKE_SHARED_LIBRARY_SONAME_(LANG)_FLAG

<0BJECTS>
This is the list of object ﬁles to be linked into the target.

<0BJECTS_QUOTED>
This is the list of object ﬁles to be linked into the target double quoted.

<0BJECT>
This is the name of the object ﬁle to be built.

<LINK_LIBRARIES>
This is the list of libraries that are linked into an executable or shared object.

<FLAGS>
This is the command line ﬂags for the linker or compiler.

<LINK_FLAGS>
This is the ﬂags used at link time.

248 Porting CMake to New Platforms and Lanquaqes

<SOURCE>

The source ﬁle name.

Language Specific Information

The following set of variables related to the compiler tools Will also be expanded.

<CMAKE_(LANG)_COMPILER>
This is the (LANG) compiler command.

<CMAKE_SHARED_L]BRARY_CREATE_(LANG)_FLAGS>
This is the ﬂags used to create a shared library for (LANG) code.

<CMAKE_SHARED_MODULE_CREATE_(LANG)_FLAGS>
This is the ﬂags used to create a shared module for (LANG) code.

<CMAKE_(LANG)_LINK_FLAGS>
This is the ﬂags used to link a (LANG) program.

<CMAKE_AR>

This is the command to create a .a archive ﬁle.

<CMAKE_RANLIB>
This is the command to ranlib a .a archive ﬁle.

11.6 Compiler and Platform Examples

Como Compiler

A good example to look at is the como compiler on Linux found in
Modules/Platforms/Linux—como.cmake. This compiler requires several non-standard
commands when creating libraries and executables in order to instantiate C++ templates.

# create a shared C++ library

set (CMAKEiCXX;CREATE#SHAREDiLIBRARY
"<CMAKE_Cxx_COMPILER> ——prelink_objects <OBJECTS>"
“<CMAKEACXXiCOMPILER>
<CMAKEiSHARED_LIBRARY_CREATE~CXX_FLAGS> <LINK¥FLAGS> —o <TARGET>
<OBJECTS> <LINK_LIBRARIES>")

L # create a C++ static library

Compiler and Platform Examples 249

;set (CMAKE_CXX—CREATE_STATIC_LIBRARY
"<CMAKE_CXX_COMPILER> ——prelink_objects <OBJECTS>"
"<CMAKE_AR> cr <TARGET> <LINK_FLAGS> <OBJECTS> "
"<CMAKE_RANLIB> <TARGET> ")

set (CMAKEVCXXiLINK_EXECUTABLE
"<CMAKEWCXX_COMPILER> —-prelink_objects <OBJECTS>"
"<CMAKEVCXX_COMPILER> <CMAKEVCXX_LINK_FLAGS> <LINK_FLAGS>
;<FLAGS> <OBJECTS> -o <TARGET> <LINKﬁLIBRARIES>")

set (CMAKE*SHAREDWLIBRARY‘RUNTIMEﬁFLAG "")
_ set (CMAKEiSHAREDﬁLIBRARY‘C_FLAGS "")
set (CMAKEWSHARED_LIBRARY_LINK_FLAGS "")

This overrides the creation of libraries (shared and static), and the linking of executable C++
programs. You can see that the linking process of executables and shared libraries requires an
extra command that calls the compiler with the ﬂag ——prelinkiobj ects, and gets all of the
object ﬁles passed to it.

Borland Compiler

The full Borland compiler rules can be found in Platforms /Windows—bcc32 . cmake. The
following code is an excerpt from that ﬁle, showing some of the features used to deﬁne rules
for the Borland compiler set.

set (CMAKE_CXX_CREATE_SHARED_LIBRARY,
"<CMAKEvCXX_COMPILER> s {CMAKEiS TARTVTEMPgFILE } -e<TARGET>
—tWD <LINK_FLAGS> —tWR <LINK_LIBRARIES>
<OBJECTS>$ {CMAKE_END7TEMP_FILE } "
"implib -c —w <TARGET7BASE>.lib <TARGET7BASE>.dll"
- )

set (CMAKEiCXX‘CREATEiSHAREDiMODULE
${CMAKEiCXX7CREATE_SHARED_LIBRARY})

# create a C shared library
L set (CMAKE7C_CREATE_SHARED7LIBRARY
"<CMAKE7C7COMPILER> ${CMAKEASTART_TEMP_FILE}-e<TARGET> -tWD
<LINK7FLAGS> —tWR <LINK_LIBRARIES>
‘ <OBJECTS>$ {CMAKEiEND_TEMP¥FI LE } "
"implib -C —w <TARGET_BASE>.lib <TARGET_BASE>.dll"
)

# create a C++ static library

250 Porting CMake to New Platforms and Lanquaqes

,set (CMAKEgCXX_CREATEiSTATIC_LIBRARY "tlib
i${CMAKEgSTART;TEMP_EILE}/p512 <LINK_FLAGS> /a <TARGETﬁQUOTED>
V<OBJECTS_QUOTED>${CMAKE_END_TEMP_FILE}")

f# compile a C++ file into an object file
iset (CMAKE_CXX‘COMPILE70BJECT
"<CMAKE__CXX_COMPILER> ${CMAKE_START7TEMP—FILE}-DWIN32 -P
<FLAGS> —o<OBJECT> -c <SOURCE>${CMAKEVEND_TEMPVFILE}")

11.7 Extending CMake

Occasionally you will come across a situation where you want to do something during your
build process that CMake cannot seem to handle. Examples of this include creating wrappers
for C++ classes to make them available to other languages, or creating bindings for C++
classes to support runtirne introspection. In these cases you may want to extend CMake by
adding your own commands. CMake supports this capability through its C plugin API. Using
this API a project can extend CMake to add specialized commands to handle project speciﬁc
tasks.

A loaded command in CMake is essentially a C code plugin that is compiled into a shared
library (a.k.a. DLL). This shared library can then be loaded into the running CMake to
provide the functionality of the loaded command. Creating a loaded command is a two step
process. You must ﬁrst write the C code and CMakeLists ﬁle for the command, and then
place it in your source tree. Next you must modify your project's CMakeLists ﬁle to compile
the loaded command and load it. We will start by looking at writing the plugin. Before
resorting to creating a loaded command you should ﬁrst see if you can accomplish what you
want with a macro. With the commands in CMake a macro/function has almost the same level
of ﬂexibility as a loaded command, but does not require compilation or as much complexity.
You can almost always, and should, use a macro/ﬁanction instead of a loaded command.

Creating a Loaded Command

While CMake itself is written in C++ we suggest that you write your plugins using only C
code. This avoids a number of portability and compiler issues that can plague C++ plugins
being loaded into CMake executables. The API for a plugin is deﬁned in the header ﬁle
cmCPluginAPI .h. This ﬁle deﬁnes all of the CMake functions that you can invoke from
your plugin. It also deﬁnes the cmLoadedCommandInfo structure that is passed to a plugin.
Before going into detail about these ﬁinctions, consider the following simple plugin:

.#include "cmCPluginAPI.h"

_static int InitialPass(void *inf, void *mf,
int argc, Char *argv[])

Extendinq CMake 251

cmLoadedCommandInfo *info = (cmLoadedCommandInfo *)inf;
info->CAPI->AddDefinition(mf, "FOO", "BAR");

return 1;
}
'void CM“PLUGIN_EXPORT
; HELLOiWORLDInit(cmLoadedCommandInfo *info)
{
info->InitialPass = InitialPass;
info->Name = "HELLO_WORLD";

First this plugin includes the cmCPluginAPI . h ﬁle to get the deﬁnitions and structures
required for a plugin. Next it deﬁnes a static function called InitialPass that will be called
whenever this loaded command is invoked. This function is always passed four parameters:
the cmLoadedCommandInfo structure, the Makeﬁle, the number of arguments, and the list of
arguments. Inside this function we typecast the inf argument to its actual type and then use it
to invoke the C API (CAPI) AddDefinition function. This function will set the variable
FOO to the value of BAR in the current cmMakefile instance.

The second function is called HELLO_WORLDInit and it will be called when the plugin is
loaded. The name of this function must exactly match the name of the loaded command with
Init appended. In this example the name of the command is HELLOiWORLD so the function is
named HELLO_WORLDInit. This function will be called as soon as your command is loaded.
It is responsible for initializing the elements of the cmLoadedCommandInfo structure. In this
example it sets the InitialPass member to the address of the InitialPass function
deﬁned above. It will then set the name of the command by setting the Name member to
"HELLOJNORLD".

Using a Loaded Command

Now let us consider how to use this new HELLO_WORLD command in a project. The basic
process is that CMake will have to compile the plugin into a shared library and then
dynamically load it. To do this you ﬁrst create a subdirectory in your project's source tree
called CMake or CMakeCommands (by convention, any name can be used). Place the source
code to your plugin in that directory. We recommend naming the ﬁle with the preﬁx Cm and
then the name of the command. For example, cmHELL07WORLD.c. Then you must create a
simple CMakeLists.txt ﬁle for this directory that includes instructions to build the shared
library. Typically this will be the following:

i project (HELLOiWORLD)

set (CMAKEiCXXwFLAGS "${CMAKE_CXX_FLAGS}"

252 Portinq CMake to New Platforms and Languages

"${CMAKE7ANSI;CXXFLAGS}"
)

:set (CMAKEiCiFLAGS "${CMAKEgCiFLAGS}"
"${CMAKE7ANSIiCFLAGS}"
)

jinclude_directories (${CMAKE_ROOT}/include
${CMAKE_ROOT}/Source
)

'addglibrary (cmHELLO_WORLD MODULE cmHELLO_WORLD.C)

It is critical that you name the library cm followed by the name of the command as shown in
the add_library call in the above example (eg. cmHELLO_WORLD). When CMake loads a
command it assumes that the command is in a library named using that pattern. The next step
is to modify your project's main CMakeLists ﬁle to compile and load the plugin. This can be
accomplished with the following code:

,# if the command has not been loaded, compile and load it
‘if (NOT COMMAND HELLOiWORLD)

# try compiling it first
try_compile (COMPILE!OK
${PROJECT_BINARY_DIR}/CMake
${PROJECTiSOURCE_DIR}/CMake
HELLO_WORLD
)

# if it compiled OK then load it
if (COMPILE_OK)
load_command (HELLOﬁWORLD
${PROJECTﬁBINARYiDIR}/CMake
${PROJECTiBINARYVDIR}/CMake/Debug
)

# if it did not compile OK, then display an error
else (COMPILE_OK)

message ("error compiling HELLO¥WORLD extension")
endif (COMPILEiOK)

endif (NOT COMMAND HELLO_WORLD)

Extending CMake 253

In the above example you would simply replace HELLOJNORLD with the name of your
command and replace ${PROJECT_SOURCE_DIR}/CMake with the actual name of the
subdirectory where you placed your loaded command. Now let us look at creating loaded
commands in more detail. We will start by looking at the cmLoadedCommandInfo structure.

itypedef const char* (*CM_DOC_FUNCTION)();

‘ typedef int (*CM'INITIAL_PASS_FUNCTION)(
’ void *info, void *mf, int argc, char *[]);

typedef void (*CMﬁFINAL_PZ—\SS_FUNCTION) (
; void *info, void *mf);
typedef void (*CMADESTRUCTORiFUNCTION) (void *info);

typedef struct {

: unsigned long reservedl;
unsigned long reservedZ;
CmCAPI *CAPI;
int mgInherited;
CMiINITIAL_PASS_FUNCTION InitialPaSS;
CMiFINAL‘PASSJE‘UNCTION FinalPass;
CMiDESTRUCTOR~FUNCTION Destructor;
CM_DOC‘FUNCTION GetTerseDocumentation;
CMiDOC_FUNCTION GetFullDocumentation;
const char *Name;
char *Error;
void *ClientData;

} cmLoadedCommandInfo;

The ﬁrst two entries of the structure are reserved for future use. The next entry, CAPI, is a
pointer to a structure containing pointers to all the CMake ﬁinctions you can invoke from a
plugin. The m_Inhe ri ted member only applies to CMake versions 2.0 and earlier. It can be
set to indicate if this command should be inherited by subdirectories or not. If you are creating
a command that will work with versions of CMake prior to 2.2 then you probably want to set
this to zero. The next ﬁve members are pointers to functions that your plugin may provide.
The InitialPass ﬁinction must be provided and it is invoked whenever your loaded
command is invoked from a CMakeLists ﬁle. The FinalPass function is optional and is
invoked after conﬁguration but before generation of the output. The Destructor function is
optional and will be invoked when your command is destroyed by CMake (typically on exit).
It can be used to clean up any memory that you have allocated in the InitialPass or
FinalPass. The next two ﬁinctions are optional and are used to provide documentation for
your command. The Name member is used to store the name of your command. This is what
will be compared against when parsing a CMakeLists ﬁle, it should be in all caps in keeping

254 Portinq CMake to New Platforms and Lamuaqes

with CMake’s naming conventions. The Error and ClientData members are used
internally by CMake, you should not directly access them. Instead you can use the CAPI
ﬁinctions to manipulate them.

Now let us consider some of the common CAPI ﬁinctions you will use from within a loaded
command. First we will consider some utility functions that are provided speciﬁcally for
loaded commands. Since loaded commands use a C interface they will receive arguments as
(int argc, char *argv [] ), for convenience you can call
GetTotalArgumentsize (argc, argv) which will return the total length of all the
arguments. Likewise some CAPI methods will return an (argc, argv) pair that you will be
responsible for freeing. The FreeArguments (argc, argv) ﬁmction can be used to free
such return values. If your loaded command has a Final Pass () then you might want to pass
data from the InitialPass () to the FinalPass () invocation. This can be accomplished
using the SetClientData (void *info, void *data) and void
*GetClientData(void *info) functions. Since the client data is passed as a void *
argument, any client data larger than a pointer must be allocated and then ﬁnally freed in your
De structor () ﬁmction. Be aware that CMake will create multiple instances of your loaded
command so using global variables or static variables is not recommended. If you should
encounter an error in executing your loaded command, you can call SetError (void
*info, const char *errorString) to pass an Error message on to the user.

Another group of CAPI functions worth noting are the cmSourceFile functions.
cmSourceFile is a C++ object that represents information about a single ﬁle including its
full path, ﬁle extension, special compiler ﬂags, etc. Some loaded commands will need to
either create or access cmSourceFile instances. This can be done using the void
*CreateSourceFile () and void * GetSource (void *mf, const Char
*sourceName) functions. Both of these functions return a pointer to a cmSourceFile as a
void * return value. This pointer can then be passed into other functions that manipulate
cmSourceFiles such as SourceFileGetProperty () 01‘ SourceFileSetProperty().

 

Chapter 12

 

Tutorials

This chapter provides a step by step tutorial that covers common build system issues that
CMake helps address. Many of these topics have been introduced in prior chapters as separate
issues but seeing how they all work together in an example project can be very helpful. This
tutorial can be found in the Tests/Tutorial directory of the CMake source code tree. Each step
has its own subdirectory containing a complete copy of the tutorial for that step.

12.1 A Basic Starting Point (Step 1)

The most basic project is an executable built from source code ﬁles. For simple projects a two
line CMakeLists ﬁle is all that is required. This will be the starting point for our tutorial. The
CMakeLists ﬁle looks like:

ycmake_minimum_required (2.6)
project (Tutorial)

_add_executable(Tutorial tutorial.cxx)

Note that this example uses lower case commands in the CMakeLists ﬁle. Upper, lower, and
mixed case commands are supported by CMake. The source code for tutorial.cxx will
compute the square root of a number and the ﬁrst version of it is very simple, as follows:

256 Tutorials

i// A simple program that computes the square root of a number
#include <stdio.h>
#include <math.h>
int main (int argc, char *argvii)
{
if (argc < 2)
. {
fprintf(stdout,"Usage: %s number\n",argv[0]);
return 1;
}
double inputValue = atof(argv[l]);
double outputValue = sqrt(inputValue);
fprintf(stdout,"The square root of %g is %g\n",
inputValue, outputValue);
return 0;

Adding a Version Number and Configured Header File

The ﬁrst feature we will add is to provide our executable and project with a version number.
While you can do this exclusively in the source code, doing it in the CMakeLists ﬁle provides
more ﬂexibility. To add a version number we modify the CMakeLists ﬁle as follows:

cmake‘minimum_required (2.6)
project (Tutorial)

# The version number.
set (Tutorial;VERSIONiMAJOR 1)
set (Tutorial;VERSlON_MINOR O)

# configure a header file to pass some of the CMake settings
# to the source code
configurerfile (
"${PROJECTﬁSOURCE‘DIR}/TutorialConfig.h.in"
"${PROJECT_BINARY_DIR}/TutorialConfig.h"
)

# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
‘includeidirectories("S{PROJECT_BINARY_DIR}")

# add the executable
add_executable(Tutorial tutorial.cxx)

A Basic Starting Point (Step 1) 257

Since the conﬁgured ﬁle will be written into the binary tree we must add that directory to the
list of paths to search for include ﬁles. We then create a TutorialConfig.h . in ﬁle in the
source tree with the following contents:

// the configured options and settings for Tutorial
i#define TutorialvVERSIONwMAJOR @Tutorial_VERSION_MAJOR@
. #define Tutorial_VERSION_MINOR @Tutorial_VERSION7MINOR@

When CMake conﬁgures this header ﬁle the values for @Tutorial_VERSION_MAJOR@ and
@Tutorial_VERSION_MINOR@ will be replaced by the values from the CMakeLists ﬁle.
Next we modify tutorial . cxx to include the conﬁgured header ﬁle and to make use of the
version numbers. The resulting source code is listed below.

:// A simple program that computes the square root of a number
‘#include <stdio.h>

i#include <math.h>

‘#include "TutorialConfig.h"

: int main (int argc, char *argv[])
. {
i if (argc < 2)
{
fprintftstdout,"%s Version %d.%d\n",

argv[0],

Tutori a17VERS I ONiMAJOR,

Tutori a17VERS I ONiMINOR) ;
fprintf(stdout,"Usage: %s number\n",argv[0]);
return 1;

}
double inputValue = atof(argv[l]);
double outputValue = sqrt(inputValue);
fprintf(stdout,"The square root of %g is %g\n",
inputValue, outputValue);
return 0;

The main changes are the inclusion of the TutorialCon fig . h header ﬁle and printing out a
version number as part of the usage message.

258 Tutorials

12.2 Adding a Library (Step 2)

Now we will add a library to our project. This library will contain our own implementation for
computing the square root of a number. The executable can then use this library instead of the
standard square root ﬁmction provided by the compiler. For this tutorial we will put the
library into a subdirectory called MathFunctions. It will have the following one line
CMakeLists ﬁle:

‘add_library(MathFunctions mysqrt.cxx)

The source ﬁle mysqrt.cxx has one function called mysqrt that provides similar
ﬁmctionality to the compiler’s sqrt ﬁlnction. To make use of the new library we add an
add_subdirectory call in the top level CMakeLists ﬁle so that the library will get built.
We also add another include directory so that the MathFunctions/mysqrt.h header ﬁle
can be found for the function prototype. The last change is to add the new library to the
executable. The last few lines of the top level CMakeLists ﬁle now look like:

i include_directories ("${PROJECT_SOURCE_DIR}/MathFunctions")
add_subdirectory (MathFunctions)‘

*# add the executable
add_executable (Tutorial tutorial.cxx)
target!link_libraries (Tutorial MathFunctions)

Now let us consider making the MathFunctions library optional. In this tutorial there really
isn’t any reason to do so, but with larger libraries or libraries that rely on third party code you
might want to. The ﬁrst step is to add an option to the top level CMakeLists ﬁle.

# Should we use our own math functions?
Option (USEiMYMATH
"Use tutorial provided math implementation" ON)

This will show up in the CMake GUI with a default value of ON that the user can change as
desired. This setting will be stored in the cache so that the user does not need to keep setting it
each time they run CMake on this project. The next change is to make the build and linking of
the MathFunctions library conditional. To do this we change the end of the top level
CMakeLists ﬁle to look like the following:

Adding a Library (Step 2) 259

f# add the MathFunctions library?
#
‘ if (USEiMYMATH)
include_directories ("${PROJECTﬁSOURCEﬁDIR}/MathFunctions")
addisubdirectory (MathFunctions)
\ set (EXTRA_LIBS ${EXTRA7LIBS} MathFunctions)
endif (USEiMYMATH)

;# add the executable
iadd_executable (Tutorial tutorial.cxx)
‘target_link_libraries (Tutorial ${EXTRAVLIBS})

This uses the setting of USEiMYMATH to determine if the MathFunctions should be compiled
and used. Note the use of a variable (EXTRA_LIBS in this case) to collect up any optional
libraries to later be linked into the executable. This is a common approach used to keep larger
projects with many optional components clean. The corresponding changes to the source code
are fairly straight forward and leave us with:

// A simple program that computes the square root of a number
'#include <stdio.h>
:#include <math.h>
‘#include "TutorialConfig.h"

f#ifdef USE_MYMATH
#include "MathFunctions.h"
##endif

‘int main (int argc, char *argv[])
{
if (argc < 2)

i

fprintf(stdout,"%s Version %d.%d\n", argle],
Tutorial_VERSION7MAJOR,
Tutorial_VERSIONiMINOR);

fprintf(stdout,"Usage: %s number\n",argv[0]);

return 1;

}
double inputValue = atof(argv[l]);
j#ifdef USE_MYMATH

double outputValue = mysqrt(inputValue);
i#else

260 Tutorials

double outputValue = sqrt(inputValue);
#endif

fprintf(stdout,"The square root of %g is %g\n”,
inputValue, outputValue);
return 0;

In the source code we make use of USEiMYMATH as well. This is provided ﬁom CMake to the
source code through the TutorialConfig.h.in conﬁgured ﬁle by adding the following
line to it:

#cmakedefine USE_MYMATH

12.3 Installing and Testing (Step 3)

For the next step we will add install rules and testing support to our project. The install rules
are fairly straight forward. For the MathFunctions library we setup the library and the header
ﬁle to be installed by adding the following two lines to MathFunctions’ CMakeLists ﬁle:

install (TARGETS MathFunctions DESTINATION bin)
install (FILES MathFunctions.h DESTINATION include)

For the application the following lines are added to the top level CMakeLists ﬁle to install the
executable and the conﬁgured header ﬁle:

# add the install targets

install (TARGETS Tutorial DESTINATION bin)

install (FILES "${PROJECT_BINARY‘DIR}/TutorialConfig.h"
DESTINATION include)

That is all there is to it. At this point you should be able to build the tutorial, then type make
install (or build the INSTALL target from an IDE) and it will install the appropriate header
ﬁles, libraries, and executables. The CMake variable CMAKE_INSTALL_PREFIX is used to
determine the root of where the ﬁles will be installed. Adding testing is also a fairly straight
forward process. At the end of the top level CMakeLists ﬁle we can add a number of basic
tests to verify that the application is working correctly.

Installing and Testing (Step 31 261

 

‘# does the application run
‘additest (TutorialRuns Tutorial 25)

# does it sqrt of 25
‘additest (TutorialComp25 Tutorial 25)

Vsetitestsiproperties (TutorialComp25
PROPERTIES PASS_REGULAR7EXPRESSION "25 is 5")

i# does it handle negative numbers
‘ additest (TutorialNegative Tutorial —25)
setAtestsiproperties (TutorialNegative
PROPERTIES PASS_REGULAR7EXPRESSION "-25 is O")

i# does it handle small numbers

, add_test (TutorialSmall Tutorial 0.0001)
‘set_testsiproperties (TutorialSmall

: PROPERTIES PASS_REGULAR_EXPRESSION "0.0001 is 0.01")

# does the usage message work?
3add_test (TutorialUsage Tutorial)
set_tests_properties (TutorialUsage
‘ PROPERTIES
PASS_REGULAR_EXPRESSION "Usage:.*number")

The ﬁrst test simply veriﬁes that the application runs, does not segfault or otherwise crash,
and has a zero return value. This is the basic form of a CTest test. The next few tests all make
use of the PASS_REGULAR_EXPRESS ION test property to verify that the output of the test
contains certain strings. In this case verifying that the computed square root is What it should
be and that the usage message is printed when an incorrect number of arguments are provided.
If you wanted to add a lot of tests to test different input values you might consider creating a
macro like the following:

i#define a macro to simplify adding tests, then use it
; macro (dogtest arg result)
add_test (TutorialComp${arg} Tutorial ${arg})
set_tests_properties (TutorialComp${arg}
PROPERTIES PASS_REGULAR7EXPRESSION ${result})
. endmacro (doitest)

# do a bunch of result based tests
do_test (25 "25 is 5")
do¥test (—25 "—25 is 0")

262 Tutorials

For each invocation of doitest, another test is added to the project with a name, input, and
results based on the passed arguments.

12.4 Adding System Introspection (Step 4)

Next let us consider adding some code to our project that depends on features the target
platform may not have. For this example we will add some code that depends on whether or
not the target platform has the log and exp functions. Of course almost every platform has
these functions but for this tutorial assume that they are less common. If the platform has log
then we will use that to compute the square root in the mysqrt function. We ﬁrst test for the
availability of these ﬁinctions using the CheckFunctionExists.cmake macro in the top
level CMakeLists ﬁle as follows:

i# does this system provide the log and exp functions?
include (CheckFunctionExists.cmake)

,check/function_exists (log HAVE_LOG)

icheck_function_exists (exp HAVE_EXP)

Next we modify the Tutor ialConf ig . h. in to deﬁne those values if CMake found them on
the platform as follows:

// does the platform provide exp and log functions?
‘#cmakedefine HAVEﬁLOG
‘ #cmakedefine HAVE_EXP

It is important that the tests for log and exp are done before the configure_file command
for TutorialConfig.h. The configure_file command immediately conﬁgures the ﬁle
using the current settings in CMake. Finally in the mysqrt function we can prOvide an
alternate implementation based on log and exp if they are available on the system using the
following code:

// if we have both log and exp then use them

i #if defined (HAVE_LOG) && defined (HAVEJXP)
result = exp(log(x)*0.5);

i#else // otherwise use an iterative approach

Adding a Generated File and Generator (Step 5)

 

12.5 Adding a Generated File and Generator (Step 5)

In this section we will show how you can add a generated source ﬁle into the build process of
an application. For this example we will create a table of precomputed square roots as part of
the build process, and then compile that table into our application. To accomplish this we ﬁrst
need a program that will generate the table. In the MathFunctions subdirectory a new source

ﬁle named Ma keTable . cxx will do just that.

// A simple program that builds a sqrt table
#include <stdio.h>
#include <math.h>

:int main (int argc, char *argv[])

: {

int i;
double result;

// make sure we have enough arguments
if (argc < 2)

{

return 1;

}

// open the output file
FILE *fout = fopen(argv[l],"w");
if (lfout)

{

return 1;

l

// create a source file with a table of square roots
fprintf(fout,"double sqrtTable[] = {\n");
for (i : O; i < 10; ++i)
{
result = sqrt(staticicast<double>(i));
fprintf(fout,"%g,\n",result);
}

// Close the table with a zero
fprintf(fout,"0};\n");
fclose(fout);

return 0;

264 Tutorials

Note that the table is produced as valid C++ code and that the name of the ﬁle to write the
output to is passed in as an argument. The next step is to add the appropriate commands to
MathFunctions” CMakeLists ﬁle to build the MakeTable executable, and then run it as part of
the build process. A few commands are needed to accomplish this, as shown below.

# first we add the executable that generates the table
. ‘ add_executable(MakeTable MakeTable.cxx)

i# add the command to generate the source code
i add_custom_command (
OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h
COMMAND MakeTable ${CMAKE_CURRENT_BINARY7DIR}/Table.h
DEPENDS MakeTable
)

:# add the binary tree directory to the search path for
‘# include files
includeidirectories( ${CMAKEiCURRENTgBINARygblR} )

_# add the main library
Iaddklibrary(MathFunctions mysqrt.cxx
${CMAKEiCURRENT_BINARY_DIR}/Table.h )

First the executable for MakeTable is added as any other executable would be added. Then
we add a custom command that speciﬁes how to produce Table . h by running MakeTable.
Next we have to let CMake know that mysqrt . cxx depends on the generated ﬁle Table .h.
This is done by adding the generated Table . h to the list of sources for the library
MathFunctions. We also have to add the current binary directory to the list of include
directories so that Table .h can be found and included by mysqrt . cxx.

When this project is built it will ﬁrst build the MakeTable executable. It will then run
MakeTable to produce Table.h. Finally, it will compile mysqrt.cxx which includes
Table. h to produce the MathFunctions library.

At this point the top level CMakeLists ﬁle with all the features we have added looks like the
following:

:cmake_minimum_required (2.6)
project (Tutorial)

# The version number.
set (Tutorial_VERSIONiMAJOR 1)
set (Tutorial_VERSIONiMINOR O)

Adding a Generated File and Generator (Step 5) 265

‘# does this system provide the log and exp functions?
include (${CMAKEiROOT}/Modules/CheckFunctionExists.cmake)

Lcheckifunction_exists (log HAVE_LOG)
‘ checkifunction_exists (exp HAVEiEXP)

# should we use our own math functions
option(USEiMYMATH
"Use tutorial provided math implementation" ON)

,# configure a header file to pass some of the CMake settings
# to the source code
configureifile (
‘ "s { PROJECTiSOURCEiDIR} /TutorialConfig. h. in"
"${PROJECT7BINARY7DIR}/TutorialCOnfig.h"
)

# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
include_directories ("${PROJECTiBINARYiDIR}")

# add the MathFunctions library?
if (USE_MYMATH)
include_directories ("${PROJECTiSOURCE_DIR}/MathFunctions")
add_subdirectory (MathFunctions)
set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)
_ endif (USE_MYMATH)

# add the executable
addiexecutable (Tutorial tutorial.cxx)‘
‘ targetilink_libraries (Tutorial ${EXTRA7LTBS})

# add the install targets
install (TARGETS Tutorial DESTINATION bin)
' install (FILES "${PROJECTvBINARYiDIR}/TutorialCOnfig.h"
DESTINATION include)

# does the application run
add_test (TutorialRuns Tutorial 25)

# does the usage message work?

add‘test (TutorialUsage Tutorial)

setitestswproperties (TutorialUsage
PROPERTIES

266 Tutorials

 

PASSWREGULAR_EXPRESSION "Usage:.*number"
)

#define a macro to simplify adding tests
(macro (doitest arg result)
add_test (TutorialComp${arg} Tutorial ${arg})
setvtests_properties (TutorialComp${arg}
PROPERTIES PASSWREGULAR_EXPRESSION ${result}
)

~endmacro (doitest)

# do a bunch of result based tests
doitest (4 "4 is 2")
do¥test (9 "9 is 3")
_ do*test (5 "5 is 2.236")
dogtest (7 "7 is 2.645")
do_test (25 "25 is 5")
~doktest (—25 "—25 is 0")
do_test (0.0001 "0.0001 is 0.0l")

TutorialConfig.h100kSHk€

// the configured options and settings for Tutorial
#define Tutorial_VERSION_MAJOR @Tutoria17VERSIONiMAJOR@
#define Tutorial_VERSION_MINOR @TutorialiVERSIONiMINOR@
#cmakedefine USE_MYMATH

// does the platform provide exp and log functions?
#cmakedefine HAVE_LOG
#Cmakedefine HAVE_EXP

Building an Installer (Step 6) 267

And the CMakeLists ﬁle for MathFunctions looks like:

i# first we add the executable that generates the table
iadd‘executable(MakeTable MakeTable.cxx)
# add the command to generate the source code
‘addicustomvcommand (
OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h
DEPENDS MakeTable
COMMAND MakeTable ${CMAKEﬁCURRENTkBINARY_DIR}/Table.h
)
‘# add the binary tree directory to the search path
# for include files
includeidirectories( ${CMAKEiCURRENTVBINARYiDIR} )

‘# add the main library
addilibrary(MathFunctions mysqrt.cxx
${CMAKEiCURRENTiBINARYgDIR}/Table.h)

install (TARGETS MathFunctions DESTINATION bin)
install (FILES MathFunctions.h DESTINATION include)

12.6 Building an Installer (Step 6)

Next suppose that we want to distribute our project to other people so that they can use it. We
want to provide both binary and source distributions on a variety of platforms. This is a little
different from the instal we did previously in section 12.3, where we were installing the
binaries that we had built from the source code. In this example we will be building
installation packages that support binary installations and package management features as
found in cygwin, debian, RPMs etc. To accomplish this we will use CPack to create platform
speciﬁc installers as described in Chapter 9. Speciﬁcally we need to add a few lines to the
bottom of our toplevel CMakeLists.txt ﬁle.

-# build a CPack driven installer package
include (InstallRequiredSystemLibraries)
: set (CPACK_RESOURCEiFILE_LICENSE
"${CMAKEiCURRENT#SOURCE_DIR}/License.txt")
set (CPACKﬁPACKAGEﬁVERSIONWMAJOR "${TutorialiVERSIONiMAJOR}")
- set (CPACK_PACKAGE_VERSIONﬁMINOR "${TutorialiVERSIONiMINOR}")
include (CPack)

That is all there is to it. We start by including InstallRequiredSystemLibraries. This module
will include any runtime libraries that are needed by the project for the current platform. Next

